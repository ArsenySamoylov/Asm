#include <stdio.h>
#include <assert.h>
#include <stdint.h>

#include <immintrin.h>

#include "blend_images.hpp"
#include "common.hpp"

int Blend(Image* front_img, Image* back_img, unsigned x_start, unsigned y_start)
    {
    assert(front_img);
    assert(back_img);

    if (front_img->width > back_img->width || front_img->height > back_img->height)
        {
        printf("front width (%u) or height (%u) Can't be bigger than back's (w:%u, h:%u)\n", 
                front_img->width, front_img->height,         back_img->width, back_img->height);

        return FAILURE;
        }

    uint32_t* back_arr  = (uint32_t*) back_img->pixel_arr + (y_start * back_img->width + x_start); 
    uint32_t* front_arr = (uint32_t*) front_img->pixel_arr; 

    for (unsigned y_coord = 0; y_coord < front_img->height; y_coord++)
        {
        for (unsigned x_coord = 0; x_coord < front_img->width; x_coord += 4)
            {
            //uint8_t alpha_back  =  back_arr->alpha_mask;
            
            static const __m256i  Red_green_mask = 
              _mm256_set_epi64x (0x00FF00FF00FF00FF, 0x00FF00FF00FF00FF, 0x00FF00FF00FF00FF, 0x00FF00FF00FF00FF);
            static const __m256i Alpha_blue_mask = 
              _mm256_set_epi64x 
              (   (__int64_t) 0xFF00FF00FF00FF00, 
                  (__int64_t) 0xFF00FF00FF00FF00, 
                  (__int64_t) 0xFF00FF00FF00FF00, 
                  (__int64_t) 0xFF00FF00FF00FF00);


            __m256i  back_color = _mm256_load_si256 ((__m256i*)  back_arr); 
            __m256i front_color = _mm256_load_si256 ((__m256i*) front_arr);
            
            __m256i  back_color_red_green = _mm256_and_si256 ( back_color,  Red_green_mask); 
            __m256i front_color_red_green = _mm256_and_si256 (front_color, Alpha_blue_mask);

            static const __m128i Alpha_head_shuffle_mask = ;
            static const __m128i Alpha_tail_shuffle_mask = ;

            // shuffle
            __m128i alpha_head = _mm_shuffle_epi32 (front_,__MM_SHUFFLE(
            __m128i alpha_tail = _mm_shuffle_epi8

            // cancatenate
            __m256i alpha = _mm256_setm128i (alpha_head, alpha_tail);
            
            // then multiply


            uint64_t new_red_green = ((front_color & 0x00FF00FF) * (alpha_front) + (back_color & 0x00FF00FF) * (256 - alpha_front)) >> 8;
            uint64_t new_alph_blue = ((front_color & 0xFF00FF00) * (alpha_front) + (back_color & 0xFF00FF00) * (256 - alpha_front)) >> 8;
            
            new_red_green &= 0x00FF00FF;
            new_alph_blue &= 0xFF00FF00;

            /*
            RGBA back_pixel = {
                               .blue  = (byte) (back_arr->blue  * (255 - alpha_back) >> 8),
                               .red   = (byte) (back_arr->red   * (255 - alpha_back) >> 8),
                               .green = (byte) (back_arr->green * (255 - alpha_back) >> 8),
                               .alpha_mask = (byte) (back_arr->alpha_mask * (255 - alpha_back) >> 8), 
                              };

            RGBA front_pixel = {
                                .blue  = (byte) (front_arr->blue  * alpha_front >> 8),
                                .red   = (byte) (front_arr->red   * alpha_front >> 8),  
                                .green = (byte) (front_arr->green * alpha_front >> 8),
                                .alpha_mask = (byte) (front_arr->alpha_mask * alpha_front >> 8),  
                               };
            */


            //*back_arr = {.red = back_pixel.red + front_pixel.red};
            
            *back_arr = (uint32_t) (new_red_green | new_alph_blue); 

            back_arr++;
            front_arr++;
            }
        
        back_arr += back_img->width - front_img->width;
        }

    return SUCCESS;
    }
