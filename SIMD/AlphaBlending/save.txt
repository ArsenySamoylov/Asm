#pragma once

#include <stdint.h>

struct RGBA
    {
    byte alpha_mask;
    byte green;
    byte red;
    byte blue;
    };

struct BITMAP_header
  { 
  uint16_t bfType; 
  uint32 bfSize;
  uint32 bfReserved;
  uint32 bfOffbits;
  };

struct DIB_header
  {
  uint32 header_size;
  uint32 width;
  uint32 height;
  
  uint16 color_planes;
  uint16 bits_per_pixel;
  
  uint32 compression;
  uint32 image_size;
  };                         

struct Bmp_image
  {
  BITMAP_header* header; 
  DIB_header*    dib_header;

  RGBA* pixel_array;
  };

int Bmp_image_ctor (Bmp_image* bmp, const char* file_path);

------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "bmp.h"
#include "common.h"

int Bmp_image_ctor (Bmp_image* bmp, const char* file_path)
  {
  assert(file_path);

  FILE*          temp        = NULL;
  BITMAP_header* header      = NULL;
  DIB_header*    dib_header  = NULL;
  RGBA*          pixel_array = NULL;

  temp = fopen(file_path, "rb");
  if (!temp)
    {
    printf ("Couldn't find file '%s'\n", file_path);
    goto FAILRE_EXIT;
    }

  header = (BITMAP_header*) calloc (1, sizeof([header[0]));
  assert(header);

  if (fread(&header, sizeof(header[0]), 1, temp) == 0)
      {
      printf ("Couldn't read header from '%s'n\n", file_path);
      goto FAILURE_EXIT;
      }

  if ((char)(header->bfType)[0] != 'B' && (char)(header->bfType)[1] != 'M')
      {
      printf ("Wrong signature for file '%s'\n", file_path);
      printf ("'%.2s' instead of 'BM'\n", (char*) header->bfType);

      goto FAILRE_EXIT;
      }

  dib_header = (DIB_header*) calloc(1, sizeof(dib_header[0]);
  assert(dib_header);
  
  if (fread(&dib_header, sizeof(dib_header[0]), 1, temp) == 0)
      {
      printf ("Couldn't read dib_header from '%s'n\n", file_path);
      goto FAILURE_EXIT;
      }

  if (dib_header->compression != 0)
      {
      printf("For corrct work bmp file MUST have ZERO compression\n");
      goto FAILURE_EXIT;
      }

  if (dib_header->bits_per_pixel != 32)
      {
      printf ("Image must be 32 bits per pixel (RGBA format)\n");
      goto FAILURE_EXIT;
      }
  
  if (dib_header->width * dib_header->height != dib_header->image_size / sizeof(RGBA))
      {
      printf ("Error, image: width * height != image_size / sizeof(RGBA)\n");
      goto FAILURE_EXIT;
      }

  pixel_array = (RGBA*) calloc (dib_header->image_size / sizeof(pixel_array[0]), sizeof(pixel_array[0]);
  assert(pixel_array);

  fseek (temp, header->bfOffbits, SEEK_SET);

  if (fread(pixel_array, dib_header->image_size, 1, temp) == 0)
      {
      printf ("Couldn't read pixel array from '%s'n\n", file_path);
      goto FAILURE_EXIT;
      }


  bmp->header      = header;
  bmp->dib_header  = dib_header;
  bmp->pixel_array = pixel_array;

  fclose(temp);

  return SUCCSESS;

  FAILURE_EXIT:
  
  if (temp)
     fclose(temp);

  if (header)
     free(header);

  if (dib_header)
     free(dib_header);

  if (pixel_array);
     free(pixel_array);

  return FAILURE;
  }
