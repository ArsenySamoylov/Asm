Это папка с учебными проектами, посвященными изучению SIMD (Single Instruction Myltiple Data) инструкций.
В каждом из каталогов можно найти более детальное описание конкретной работы. Далее будет более подробно описана работа, в виде небольшой лабораторной работы. 

# Введение
SIMD-инструкции позволяют выполнять арифметические, логические и другие более специфичные операции над несколькими элементами одновременно. 		 
Эти инструкции можно рассматривать как работу с векторами.
Например: умножение восьми целых чисел на константу, побитовый сдвиг или почленное вычитание с другим вектором из целых чисел. 
	
# Актуальность
Есть множество задач, в которых над большим объемом данных, с каждым элементом производятся схожие операции. Ярким пример служит работа с изображениями, где происходят многочисленные повторяющееся вычисления с каждым отдельным пикселем для получения результата, готового к отображению на экран.

# Цели
1. Определить эффективность SIMD-инструкций.
2. Научится работать с SIMD инструкциями на примере задач:
	+ отображение множества Мандельброта 
	+ Альфа-блендиг
	
# Задачи
1. Написать две версии функции, отображающей множество Мандельброта. Первая версия функции использует стандартные методы языка С, а вторая дополнительно использует SIMD инструкции.
2. Попытаться максимально оптимизировать первую версию программы.
2. Измерить затраченное время на работу каждой из версий программы и сравнить полученные результаты.
3. Аналогичную работу произвести для задачи Альфа-блендинга.
	
# Гипотеза
При повторяющей обработке большого количества данных, зачастую лучшего время исполнения алгоритма можно добиться только с помощью SIMD инструкций.
	
# Ход работы
## Справка
Далее будут изложены краткие итоги работы. Более подробное описание каждой из двух задач можно найти в соответствующей папке с названием работы.
В каждой из папок находится:
1. детальное описание.
2. функции работающие с массивами данных с SIMD инструкциями и без
3. исходники небольшой программы замеряющий время, потраченное на вызов в цикле соответствующих функций (количество вызовов задается константой *NUMBER_OF_ITERATIONS_FOR_MEASURMENT* при компиляции) и выводящей результат измерений в консоль. Так же программа с помощью графической библиотеки SFML показывает результат работы функций в отдельном окне.

**Важно** в проекте для измерения потраченного на измерение времени используется *timeval* структура, определенная в <sys/time.h>, специфичная для Linux системы. Поэтому код, скорее всего не cкомпилируются для другой платформы. Так же система должны поддерживать наборы SIMD инструкций AVX и AVX2.

### Как работать с SIMD-инструкциями?
Первый способ — это писать напрямую на ассемблере, например с помощью ассемблерной вставки asm{} в Си.
Второй способ — это использовать так называемые intrinsic функции. Этот подход предпочтительнее. 

Во-первых, что такое intinsic функции? Intinsic функции — это встроенные функции, для которых в компиляторе на самом деле реализована особая обработка. При вызове intrinsic-функции компилятор генерирует особый код: вместо вызова функции будет подставлено несколько машинных инструкций, выполняющих нужную задачу. Важно отметить, что у разных компиляторов разный набор intrinsic-ов. 
Именно такие intrinsic-и, определенные в заголовочном файле #include *<immintrin.h>* и будут помогать генерировать нужный код с использованием SIMD-инструкций. Главное преимущество такого кода перед ассемблерной вставкой состоит в том, что компилятор может оптимизировать код использующий такие функции, в то время как при работе с ассемблерной вставкой компилятор отключает все оптимизации.

### Наборы SIMD-команд
 Как было сказано раннее, intrinsic функции заставляют генерировать определенный машинный код и специальные intrinsic-и позволят использовать SIMD инструкции. Но возникает следующая проблема — не все процессоры поддерживают одинаковые наборы SIMD-команд. Существует несколько стандартных наборов команд, например, основные из них для процессоров х86-64 это: FMA, AVX, SSE и MMX. Так как из этих наборов, самый новый, который поддерживает мой компьютер это AVX2, то именно этот набор команд в основном будет использоваться при работе с intrinsic-ами (далее аббревиатура *avx* будет обозначать, что используется набор команд AVX и AVX2).  
 
### Методика измерений
В данной работе главным показателем будем считать время, затраченное на работу функции, выполняющей основные вычисления. Так как время, затрачиваемое на один высов функции мало, а так же функция работает в системе не изолировано (т.е могут происходить внешние события, что отражается на общем времени работы функции), то следует измерять время работы нескольких вызовов одной и той же функции. Это позволит понизить погрешности измерений и получить более достоверный результат для сравнения между другими функциями.
Так как алгоритмы расчета в обеих задачах достаточно просты и их оптимизация не приведет к значительному изменению времени работы функции, то оптимизироваться будет создаваемый компилятором машинный код. Для этого, оптимизированной версией функции будем считать ту, которая компилировалась с флагом **-О3**. Для компиляции будем использовать *gcc version 11.3.0*.

## Мандельброт
Таблица показывающее среднее значение времени, затраченного при выполнении *NUMBER_OF_ITERATIONS_FOR_MEASURMENT = 500* вызовах соответствующих функций
| Название Функции			| Время не оптимизированной функции		       | Время оптимизированной функции (-O3) 
|---------------------------------------|------------------------------------------------------|----------------------------------------------
| CalculateMandalbrot_no_avx		| 19.39						       | 16.69
| CalculateMandalbrot_optimized_avx     | 3.09                                                 | 2.86

Отношение среднего времени на работу версии с SIMD-инструкциями к времени работы функции без них


|  без SIMD (неоптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (оптим.)
|----------------------------------------|-------------------------------------|---------------------------------------------
| 6.27			     		 | 5.40				       | 5.67

Данные результаты показывают, что даже не оптимизированная версия функции, написанной с использованием SIMD-инструкций, работает заметно быстрее оптимизированной версии обычной функции.

## Альфа-блендинг

Таблица показывающее среднее значение времени, затраченного при выполнении *NUMBER_OF_ITERATIONS_FOR_MEASURMENT = 10000* вызовах соответствующих функций
| Функция				| Не оптимизированные функции			       | Оптимизированные функции (-O3) 
|---------------------------------------|------------------------------------------------------|----------------------------------------------
| Blend_no_avx				| 64.13						       | 19.07
| Blent_optimized_avx		        | 34.15                                                | 4.73

Отношение среднего времени на работу версии с SIMD-инструкции к времени работы функции без них
|  без SIMD (неоптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (неоптим.) | без SIMD (оптим) / SIMD (оптим)
|----------------------------------------|-------------------------------------|---------------------------------------------
| 1.881			     		 | 0.556			       | 4.014


В данном случае у оптимизированной версии получилось "обогнать" не оптимизированную версию с SIMD. Тем не менее, оптимизированная версия c SIMD инструкция не оставила никаких шансов соперникам, показав лучший результат.

### Краткий итог после измерений
Данные работы показывают, что использование SIMD инструкций дает большое преимущество, значительно сокращая время на выполнение расчетов.

# Заключение
SIMD инструкций показали отличные показатели для достижения минимального времени обработки изображений. С их помощью получилось в несколько раз ускорить вычисления.

Но, при написании кода на intrinsic-ая выявились следующие минусы:
1. код становится аппаратно зависимым, так как набор SIMD-инструкций зависят от конкретной модели процессора. Поэтому у такого кода есть проблемы с переносимостью.
2. Читабельность кода падает, объем растет, и время разработки увеличивается. Так как использование intrinsic-ов схоже с написанием кода на ассемблере, то появляются схожие проблемы, как и при написании ассемблерного кода.

Подводя итог, можно сказать, что SIMD-инструкции помогают добиться значительного уменьшения время обработки больших массивов данных. Однако такой подход приносит некоторые трудности и особенности, например сложно читаемый объемный код и проблемы с совместимостью. 
Поэтому, мое личное мнение, что стоит использовать SIMD инструкции только в том случае, когда важно значительно снизить время работы алгоритма, а оптимизации другими способами не помогают достичь желаемого результата. Для функций, занимающих небольшую часть от общего времени работы программы, я бы не рекомендовал использование SIMD-инструкций.
