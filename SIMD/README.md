Это папка с учебными проектами, посвященными изучению SIMD (Single Instruction Myltiple Data) инструкций.
В каждом из каталогов можно найти более детальное описание конкретной работы. Далее будет более подробно описана работа, в виде небольшой лабораторной работы. 

# Введение:
SIMD инструкции позволяют выполнять арифметические, логические и другие более специфичные операции над несколькими элементами одновременно. 		 
Эти инструкции можно рассматривать как работу с векторами.
Например: умножение восьми целых чисел на константу, побитовый сдвиг или почленное вычитание с другим вектором из целых чисел. 
	
# Актуальность:
Есть множество задач, в которых над большим объемом данных, с каждым элементом производятся схожие операции. Ярким пример служит работа с изображениями, где происходят мночогчисленные повторяющиейся вычисления с каждым отдельным пикселем для получения результата, готового к отображения на экран.

# Цели:
1. Опредилить эффективность SIMD инструкций.
2. Научится работать с SIMD инструкциями на примере задач:
	+ отображение множества Мандельброта 
	+ Альфаблендиг
	
# Задачи:
1. Написать 2 версии функции, отображающей множество Мандельброта. Первая версия функии использует стадартные методы языка С, а вторая дополнительно использует SIMD инструкции.
2. Попытаться максимально оптимизировать первую версию программы.
2. Измерить затраченое время на работу каждой из версий программы и сравнить полученные результаты.
3. Аналогичную работу произвести для задачи Альфаблендинга.
	
# Гипотеза:
При повторяющей обработке большого количества данных, зачастую лучшего время исполнения алгоритма можно добится только с помощью SIMD инструкций.
	
# Ход работы:
## Справка
Далее будут изложены краткие итоги работы. Более подробное описание каждой из двух задач можно найти в соотвествующей папке с названием работы.
В каждой из папок находится:
1. детальное описание.
2. функции работающие с массивами данных с SIMD инструкциями и без
3. исходники небольшой программы замеряющий время, потраченное на вызов в цикле соответсвующих функций (количество вызовов задается константой *NUMBER_OF_ITERATIONS_FOR_MEASURMENT* при компиляции) и выводящей результат измерений в консоль. Так же программа с помощью графической библиотеки SFML показывает результат работы функций в отдельном окне.

**Важно** в проекте для измерения потраченного на измерение времени используется *timeval* структура, определенная в <sys/time.h>, специфичная для Linux системы. Поэтому код, скорее всего не скомпилируются для другой платформы. Так же система должны поддерживать наборы SIMD инструкций AVX и AVX2.

### Как работать с SIMD инстрункциями?
Первый способ - это писать напрямую на ассемблере, например с помощью ассемлерной вставки asm{} в Си.
Второй способ - это использовать так называемые intrinsic функции. Этот подход предпочтительнее. 

Во первых, что такое intinsic функции? Intinsic функции - это есть встроенные функции, для которых в компиляторе на самом деле реализована особая обработка. У разных компиляторов набор intrinsic-ов разный. При вызове intrinsic-функции компилятор генерирует особый код: не генерируется вызова какой-либо функции, вместо этого будет подставленоо несколько машинных инструкций, выполняющих нужную задачу.
Именно такие intrinsic-и, определенные в заголовочном файле #include *<immintrin.h>* и будут помогать генерирровать нужный код с использованием SIMD инструкциий. Главное преимущество такого кода перед ассемблерной вставкой состоит в том, что компилятор может оптимизировать код использующий такие функции, в то время как при работе с ассемблерной вставкой компилятор отключает все оптимизации.

### Наборы SIMD команд
 Как было сказано раннее, intrinsic функции заставляют генерировать определенный машинный код и специальные intrinsic-и позволят использовать SIMD инструкции. Но возникает следующая проблема - не все процессоры подерживают одинаковые наборы SIMD команд. Существует несколько стандартных наборов команд, например, основные из них для процессоров х86-64 это: FMA, AVX, SSE и MME. Так как из этих наборов, самый новейший, который поддерживает мой компьютер это AVX2, то именно этот набор команд в основном будет использоваться при работе с intrinsic-ами (далее абревиатура *avx* будет обозначать, что используется набор команд AVX и AVX2).  
 
### Методика измерений
В данной работе главным показателем будем считать время, затраченное на работу функиции, выполняющей основные вычисления. Так как время, затрачиваемое на один высов функции мало, а так же функция работает в системе не изолировано (т.е могут происходить внешние события, что отражается на общем времени работы функции), то следует измерять время работы нескольких вызовов одной и той же функции. Это позволит понизить погрешности измерений и получить более достоверный результат для сравнения между другими функциями.
Так алгоритмы расчета в обоих задач достаточно просты и их оптимизизация не приведет к значительному изменению времени работы функции, то оптимизироваться будет создаваемый компилятором машинный код. Для этого, оптимизированной версией функции будем считать ту, которая компилировалсь с флагом **-О3**. Для компиляции будем использовать gcc version 11.3.0.

## Мандельброт:
Таблица показывающее среднее значение времени, затраченного при выполнении *NUMBER_OF_ITERATIONS_FOR_MEASURMENT = 500* вызовах соответсвующих функциий
| Название Функции			| Время неоптимизированной функции		       | Время оптимизированной функции (-O3) 
|---------------------------------------|------------------------------------------------------|----------------------------------------------
| CalculateMandalbrot_no_avx		| 19.39						       | 39.21
| CalculateMandalbrot_optimized_avx     | 3.09                                                 | 14.46

Отношение среднего времени на работу версии с SIMD иснструкции к времени работы функции без них


|  без SIMD (неоптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (оптим.)
|----------------------------------------|-------------------------------------|---------------------------------------------
| 2.7			     		 | 1.34				       | 6.26

Данные результаты показывают, что даже неоптимизированная версиия функции, написанной с использование SIMD инструкций, работает заметно быстрее оптимизированной версии обычной функции.

## АльфаБлендинг:

Таблица показывающее среднее значение времени, затраченного при выполнении *NUMBER_OF_ITERATIONS_FOR_MEASURMENT = 10000* вызовах соответсвующих функциий
| Функция				| Не оптимизированные функции			       | Оптимизированные функции (-O3) 
|---------------------------------------|------------------------------------------------------|----------------------------------------------
| Blend_no_avx				| 64.13						       | 19.07
| Blent_optimized_avx		        | 34.15                                                | 4.73

Отношение среднего времени на работу версии с SIMD иснструкции к времени работы функции без них
|  без SIMD (неоптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (неоптим.) | без SIMD (оптим) / SIMD (оптим)
|----------------------------------------|-------------------------------------|---------------------------------------------
| 1.881			     		 | 0.556			       | 4.014


В данном случае у оптимизированоой версии получилось "обогнать" неоптимизированную версию с SIMD. Но тем не менее, оптимизированная версия c SIMD инструкция не оставила никаких шансов соперникам, показав лучший результат.

### Краткий итог после измерений
Данные работы показывают, что использование SIMD инструкций дает большое преимущество, значительно сокращая время на выполнение расчетов.

# Заключение:
SIMD инструкций показали отличныые показатели для достижения минимального времени обработки изображений. С их помощью получилось в несколько раз ускорить вычисления.

Но, при написании кода на intrinsic-ая выявились следующие минусы:
1. код становится аппартно зависимым, так как наборв SIMD инструкций зависят от конкретной модели процессора. Поэтому у такого кода есть проблемы с переносимостью.
2. Читабельность кода падает, объем растет, и время разработки увеличивается. Так как использование intrinsic-ов схоже с написанием кода на ассемблере, то появляются схожие проблемы, как и при написании асемблерного кода.

Подводя итог, можно сказать, что SIMD иструкции помогают добится значительного уменьшения время обработки больших массивов данных. Однако такой подход приносит некоторые трудности и особенности, например сложночитаемый объемный код и проблемы с совместимостью. 
Поэтому, мое личное мнение, что стоит использовать SIMD инструкции тольк в том случае, когда важно значительно снизить время работы алгоритма, а оптимизации другими способами не погают достичь желаемого результата. Для функций же, занимающих небольшую часть от общего времени работы программы, я бы не рекоммендовал использование SIMD инструкциий.
