Это папка с учебными проектами, посвященными изучению SIMD (Single Instruction Myltiple Data) инструкций.
В каждой из каталогов можно найти более детальное описание конктретной работы. Далее будут более подробно описана работа, в виде небольшой лабораторной работы. 

# Введение:
SIMD инструкции позволяют выполнять арифметические, логические и другие более специфичные операции над несколькими элементами одновременно. 		 
Эти инструкции можно рассматривать как работу с векторами.
Например: умножение 8-ми целых чисел на константу, побитовый сдвиг или почленное вычитание с другими 8-мью целыми числами. 
	
# Актуальность:
Есть множество задач, в которых над большим объемом данных с каждым элементом производятся схожие операции. Ярким пример служит работа с графикой, где происходят мночогчисленные повторяющиейся вычисления с каждым пикселем для получения результата, готового к отображения на экран.

# Цели:
1. Опредилить эффективность SIMD инструкций.
2. Научится работать с SIMD инструкциями на примерах задач:
	+ отображение множества Мандельброта 
	+ Альфаблендиг
	
# Задачи:
1. Написать 2 версии функции, отображающей множество мандельброта. Первая версия функии использует стадартные методы языка С, а вторая дополнительно использует SIMD инструкции.
2. Попытаться максимально оптимизировать перввую версию программы.
2. Измерить затраченое время на работу каждой из версий программы и сравнить полученные результаты.
3. Аналгичную работу произвести для задачи АльфаБлендинга.
	
# Гипотеза:
При повторяющей обработке большого колличесва данных зачастую лучшего время исполнения алгоритма можно добится только с помощью SIMD инструкций.
	
# Ход работы:
## Справка
Далее будут изложены краткие итоги работы. Более подробное описание каждой из двух задач будкт лежать в соотвествующей папке с название работы.
В каждой из папок находится:
1. детальное описание.
2. функции работающие с массивами данных с SIMD инструкциями и без
3. исходники небольшой простой программы замеряющий временя, потраченное на вызов в цикле соответсвующих функций (количество вызовов задается константой *NUMBER_OF_ITERATIONS_FOR_MEASURMENT* при компиляции) и выводящей результат измерений в консоль. Так же программа с помощью графической библиотеки SFML показывает результат работы функций в отдельном окне. Для просмотра результатов измерений без графического сопроврождения нужно скомпильровать с опцией -D NO_SFML или прописать

`make no_sfml`

**Важно** в проекте для измерения потраченного на измерение времени используется timeval структура, определенная в <sys/time.h>, специфичная для Linux системы. Поэтому код, скорее всего не скомпилируются для другой платформы. Так же система должны поддерживать наборы SIMD инструкций AVX и AVX2

### Как работать с SIMD инстрункциями?
Первый способ - это писать напрямую на ассемблере, например с помощью ассемлерной вставки asm{} в Си.
Второй способ - это использовать так называемые intrinsic функции. Этот подход более предпочтительный. 

Во первых, что такое intinsic функция? Intinsic функции - это есть поистине встроенные функции, для которых в компиляторе на самом деле реализована особая обработка. У разных компиляторов набор intrinsic-ов разный. При вызове intrinsic-функции компилятор генерирует особый код, характерный именно для данной функции: не генерируется вызова какой-либо функции, вместо этого будет подставленоо несколько машинных инструкций, выполняющих нужную задачу.
Именно такие intrinsic-и, определенные в заголовочном файле #include *<immintrin.h>* и будут помогать нам генерирровать нужный нам код с использование SIMD инструкциий. Главное преимущество такого кода перед ассемблерной вставкой состоит в том, что компилятор может оптимизировать код использующий такие функции, в то время как при работе с ассемблерной вставкой компилятор отключает все оптимизации.

### Наборы SIMD команд
 Как было сказано раннее, intrinsic функции заставляют генерировать определенный машинный код и специальные intrinsic-и позволят использовать SIMD инструкции. Но возникает следующая проблема - не все процессоры подерживают одинаковые наборы SIMD команд. Существует несколько стандартных наборов команд, например, основные из них для процессоров х86-64 это FMA, AVX, SSE и MME. Так как из этих наборов, самый новейший, который поддерживает мой компьютер это AVX2, то именно этот набор команд в основном будет использоваться при работе с intrinsic-ами. (далее абревиатура avx будет обозначать, что измпользуется набор команд AVX и AVX2)  
 
### Методика измерений
В данной работе главным показателем будем считать время затраченное на работу функиций, выполняющей основные вычисления. Так как время, затрачиваемое на один высов функций мало, а так же функция работает в системе не изолировано (т.е могут происходить внешние события, чье влияние отражаюется на общем вермение работы функции), то следует измерять время работы нескольких вызовов одной и той же функции несколько раз. Это позволит понизить погрешности измерений и получить более достоверный результат для сравнения.
Оптимизация функций будем производиться с помощью флага компиляции **-О3**

## Мандельброт:
Таблица показывающее среднее значение времени, затраченного при выполнении *NUMBER_OF_ITERATIONS_FOR_MEASURMENT = 500* вызовах соответсвующих функциий
| Название Функции			| Время неоптимизированной функции		       | Время оптимизированной функции (-O3) 
|---------------------------------------|------------------------------------------------------|----------------------------------------------
| CalculateMandalbrot_no_avx		| 19.39						       | 39.21
| CalculateMandalbrot_optimized_avx     | 3.09                                                 | 14.46

Отношение среднего времени на работу версии с SIMD иснструкции к времени работы функции без них


|  без SIMD (неоптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (неоптим.) | без SIMD (оптим) / SIMD (оптим)
|----------------------------------------|-------------------------------------|---------------------------------------------
| 2.7			     		 | 1.34				       | 6.26

Данные результаты показывают, что даже неоптимизированная версиия функции, написанной с использование SIMD инструкций, работает заметно быстрее оптимизированной версии обычной функции.

## АльфаБлендинг:

Таблица показывающее среднее значение времени, затраченного при выполнении *NUMBER_OF_ITERATIONS_FOR_MEASURMENT = 10000* вызовах соответсвующих функциий
| Функция				| Не оптимизированные функции			       | Оптимизированные функции (-O3) 
|---------------------------------------|------------------------------------------------------|----------------------------------------------
| Blend_no_avx				| 64.13						       | 19.07
| Blent_optimized_avx		        | 34.15                                                | 4.73

Отношение среднего времени на работу версии с SIMD иснструкции к времени работы функции без них
|  без SIMD (неоптим.) / SIMD (неоптим.) | без SIMD (оптим.) / SIMD (неоптим.) | без SIMD (оптим) / SIMD (оптим)
|----------------------------------------|-------------------------------------|---------------------------------------------
| 1.881			     		 | 0.556			       | 4.014


В данном случае у оптимизированоой версии получилось "обогнать" неоптимизированную версию с SIMD. Но тем не менее, оптимизированная версия c SIMD инструкция не оставила никаких шансов соперникам, показав лучший результат.

### Краткий итог после измерений
Данные работы показывают, что использование SIMD инструкций дает большое преимущество, значительно сокращая время на выполнение расчетов.

# Заключение:
SIMD инструкций показали отличныые показатели для достижения минимального времени обработкми изображений. С их помощью получилось в несколько раз ускорить вычисления.

Но, при написании кода на intrinsic-ая выявились следующие минусы:
1. код становится аппартно зависимым, так как наборв SIMD инструкций зависят от конкретной модели процессора. Поэтому у такого кода есть проблемы переносимостью.
2. Читабельность кода падает, объем растет, и время разработки увеличивается. Так как использование intrinsic-ов схожее с кодом на ассемблере, то появляются схожие проблемы, как и при написании асемблерного кода.

Подводя итог, можно сказать, что SIMD иструкции помогают добится значительного уменьшия время обработки больших массивов данных. Однако такой подход приносит некоторые трудности и особенности, например сложночитаемый объемный код и проблемы с совместимостью. 
Поэтому, мое личное мнение, что стоит использовать SIMD инструкции тольк в том случае, когда важно значительно снизить время работы алгоритма, а оптимизации другими способами не погают достичь желаемого результата. Для функций же, занимающих небольшую часть от общего времени программы, я бы не рекоммендовал использование SIMD инструкциий.
