# Введение
В данном репозитории находится работа, посвященная изучению структуры данных - хеш-таблицы.
Исследование состоит из двух частей:
1. Рассмотрение нескольких хеш-функций.
2. Оптимизация поиска в хеш-таблице.

<hr>

# <a name="section-experimental-setup"></a> Экспериментальная установка
Ноутбук фирмы "Acer" на процессоре "Intel(R) Core(TM) i5-10300H CPU @ 2.50GHz" и операционная система "GNU/Linux 22.04.1-Ubuntu x86_64".

# Теоретическое введение
**Хеш-таблица** — это ассоциативный массив, в котором все элементы хранятся в виде пары ключ-значение, где:

*ключ* — уникальное число, которое используется для индексации значений;

*значение* (или элемент) — данные, которые с этим ключом связаны. 

*Хеш-функция* — функция, сопоставляющая ключу число, которое в последствии используется для вычисления индекса в ассоциативном массиве.

Важно, что хеш-функция не обязана выдавать уникальные числа для разных *значений*. Ситуации, когда несколько *значений* имеют одинаковые *ключи*, называют *коллизиями*. Один из способов борьбы с *коллизиями* - это **метод цепочек**.

Суть этого метода проста: если хеш-функция выделяет один индекс разным элементам, то храниться они будут в одном и том же индексе, но уже с помощью списка (далее вместо *индекса* мы будем использовать термин *контейнер* или *список* под данным индексом).

Именно этот метод будем использовать в данной работе.

Визуализация хеш-таблицы методом цепочек, взятом из [данного источника](https://www.geeksforgeeks.org/implementing-our-own-hash-table-with-separate-chaining-in-java/?type=article&id=137749)[^1] (там же можно подробнее узнать о том, как работает хеш-таблица).

![hash table visualization](resources/readme_pic/hashatable_exmp.png)

# Ход работы

## **Первая часть**
Быстрота взаимодействия с хеш-таблицей напрямую зависит от её заселенности (среднего количества элементов в контейнерах) и равномерности заполнения. Хеш-таблица считается хорошей, когда в среднем в каждом контейнере 1.5-2 элементов.

За основной параметр для исследований в первой части возьмем *равномерность заполнения*.

Для анализа хеш-функций мы будем симулировать ситуацию, когда в каждом контейнере примерно 20-25 элементов. Данная ситуация позволяет более отчетливо выявить неравномерность распределения элементов хеш-функцией.

В качестве элементов выберем английские слова. В хеш-таблице будут храниться только уникальные слова, так как в противном случае на распределение будет так же влиять частота всречи слов.

Главное преимущество хеш-таблицы - это маштабируемость вместительности таблицы. Взаимодействие с хеш-таблицей должно быть быстрым как при маленьких, так и при больших размерах. Поэтому для хорошей репрезентативности мы будем измерять равномерность распределения при трех размерах:
- 227 контейнеров;
- 1,013 контейнеров;
- 10,007 контейнеров;
 
Для количества контейнеров лучше всего подбирать *простые числа*. Так как, при существовании зависимости между данными, хеш-функции могут выдавать значения с определенными закономерностями, и нахождения остатка от деления на непростое число может быть хуже распределенным, чем при делении на *простое*.

### **Хеш-функции**
Далее будут приведены восемь различных функций вместе с гитограмамми, показывающие распределение при разном количестве контейнеров.

Функции написаны на Си. В каждой функции используется следующие псевдонимы к базовым типам:

```
typedef char data;
typedef unsigned index_t;
```

### **1. hash1_always_1**
```
index_t hash1_always_1 (const data* key)
    {
    assert(key);
    return 1;
    }
```

Данная хеш-функция всегда возвращает единицу. 
Так как все элементы хранятся в одном контейнере, то ниже приведена гистограмма только при одном количестве контейнеров.

<details>
<summary> Гистограмма 1. Распределение функции hash1_always_1. </summary>

![Распределение функции hash1_always_1.](resources/readme_pic/hash1_always1_227.png)

</details>

### **2. hash2_ascii**
```
index_t hash2_ascii (const data* key)
    {
    assert(key);
    return (index_t) *( (const char *) key);
    }
```
Данная хеш-функция возвращает ASCII код первого символа.
Одной гистограммы достаточно, чтобы увидеть ограниченность распределения.
<details>
<summary> Гистограмма 2. Распределение функции hash2_ascii. </summary>

![Распределение функции hash2_ascii.](resources/readme_pic/hash2_ascii_227.png)

</details>

### **3. hash3_strlen**
```
index_t hash3_strlen   (const data* key)
    {
    assert(key);
    return assert(key), (index_t) strlen( (const char*) key);
    }
```
Данная хеш-функция возвращает длину слова.
Одной гистограммы достаточно, чтобы у видеть ограниченность распределения.

<details>
<summary> Гистограмма 3. Распределение функции hash3_strlen. </summary>

![Распределение функции hash3_strlen.](resources/readme_pic/hash3_strlen_227.png)

</details>

### **4. hash4_hash_sum**
```
index_t hash4_hash_sum (const data* key)
    {
    assert(key);

    const char* temp = (const char*) key;
    index_t hash_sum = (index_t) *temp;

    while (*temp)
        hash_sum += (index_t) *temp++;

    return hash_sum;
    }
```

Данная хеш-функция возвращает сумму всех ASCII кодов слова.
Распределение этой функции уже интереснее. Только на самом большом количесве контейнеров видна ограниченость этой функции. 

Специально для этой функции привожу гистограмму для распределения по `5023` контейнерам для лучшей наглядности.

<details>
<summary> Гистограммы 4. Распределение функции hash4_hash_sum. </summary>

![Распределение функции hash4_hash_sum.](resources/readme_pic/hash4_hash_sum_227.png)

![Распределение функции hash4_hash_sum.](resources/readme_pic/hash4_hash_sum_1013.png)

![Распределение функции hash4_hash_sum.](resources/readme_pic/hash4_hash_sum_10007.png)

![Распределение функции hash4_hash_sum (дополнительно).](resources/readme_pic/hash_sum_bad_side.png)

</details>

### **5. hash5_rol**
```
static inline index_t rol (index_t val)
    {
    return ((val << 1) | (val >> 31));
    }

index_t hash5_rol (const data* key)
    {
    assert(key);
    
    index_t hash_value = 0;
    const char* temp = (const char*) key;

    while (*temp)
        hash_value = rol (hash_value) ^ (index_t) *(temp++);

    return hash_value;
    }
```
Данная хеш-функия возвращает результат побитовой операции `XOR` элементa строки с промежуточным значением хеша, полученным во время циклического сдвига влево. 

<details>
<summary> Гистограммы 5. Распределение функции hash5_rol. </summary>

![Распределение функции hash5_rol.](resources/readme_pic/hash5_rol_227.png)

![Распределение функции hash5_rol.](resources/readme_pic/hash5_rol_1013.png)

![Распределение функции hash5_rol.](resources/readme_pic/hash5_rol_10007.png)

</details>

### **6. hash6_ror**
```
static inline index_t ror (index_t val)
    {
    return ((val >> 1) | (val << 31));
    }

index_t hash6_ror (const data* key)
    {
    assert(key);
    
    index_t hash_value = 0;
    const char* temp = (const char*) key;

    while (*temp)
        hash_value = ror (hash_value) ^ (index_t) *(temp++);

    return hash_value;
    }
```
Данная хеш-функция подобна предыдущей, только циклический сдвиг происходит вправо.

<details>
<summary> Гистограммы 6. Распределение функции hash6_ror. </summary>

![Распределение функции hash6_ror.](resources/readme_pic/hash6_ror_227.png)

![Распределение функции hash6_ror.](resources/readme_pic/hash6_ror_1013.png)

![Распределение функции hash6_ror.](resources/readme_pic/hash6_ror_10007.png)

</details>

### **7. hash7_gnu**
```
index_t hash7_gnu (const data* key)
    {
    assert(key);

    index_t hash = 5381;
    char c = 0;
    
    const char* temp = (const char*) key;

    while (c = *(temp++))
        hash = ((hash << 5) + hash) + (index_t) c;

    return hash;
    }
```
Алгоритм данной хеш-функции использует линейную комбинацию элементов значения с коэффициентами, полученными перемножением простых чисел.

<details>
<summary> Гистограммы 7. Распределение функции hash7_gnu. </summary>

![Распределение функции hash7_gnu.](resources/readme_pic/hash7_gnu_227.png)

![Распределение функции hash7_gnu.](resources/readme_pic/hash7_gnu_1013.png)

![Распределение функции hash7_gnu.](resources/readme_pic/hash7_gnu_10007.png)

</details>

### **8. hash8_crc32**
```
index_t  hash8_crc32 (const data* key)
  {
    if (!key) return 0;

    const index_t polynomial = 0x04C11DB7;
    const index_t polOldBit  = 1 << 26;

    index_t hash = 0;
    const char* reference = (const char*) key;

    while (*reference)  
        {
        for (int i = 7; i >= 0; i--)
            {
            hash = (hash << 1) + ((*reference >> i) & 1);
            if (hash & polOldBit)
              hash ^= polynomial;
            }

        ++reference;
        }

    return hash;
  }
```

Алгоритм данной хеш-функции можно описать как полиномиального деления в столбик (вместо деления - `XOR`).

<details>
<summary> Гистограммы 8. Распределение функции hash8_crc32. </summary>

![Распределение функции hash8_crc32.](resources/readme_pic/hash8_crc32_227.png)

![Распределение функции hash8_crc32.](resources/readme_pic/hash8_crc32_1013.png)

![Распределение функции hash8_crc32.](resources/readme_pic/hash8_crc32_10007.png)

</details>
Расчитаем дисперсии для функций.

<br>

##### **Таблица 1**. Дисперсия функций в условных единицах.
| Название Функции | 227 контейнеров | 1,013 контейнеров |10,007 контейнеров 
|------------------|-----------------|-------------------|-------------
| `hash1_always_1` | 118,341         | 216,404           | 4,277,642
| `hash2_ascii`    | 4,639           | 126,212           | 297,420
| `hash3_strlen`   | 15,770          | 21,565            | 429,006
| `hash4_hash_sum` | 265             | 104               | 30,333
| `hash5_rol`      | 25.18           | 21.68             | 102
| `hash6_ror`      | 54.09           | 36.38             | 489
| `hash7_gnu`      | 25.72           | 14.99             | `20.52`
| `hash8_crc32`    | `23.99`         | `14.76`           | 20.85

<details>
<summary> Приложение 1. Дисперсии четырех лучших функций. </summary>

![variance](resources/readme_pic/variance.png)

</details>
<br /> 

### **Вывод из первой части**
Из полученных данных видно, что лучшими показателями (наименьшей дисперсией) обладают функции `hash7_gnu` и `hash8_crc32`.

## **Вторая часть**

<hr>

### *Замечание*
Далее во второй части все версии тестовой модели будут компилироваться с флагом оптимизации `-О3`
<hr>

### **Что делаем теперь?**
Первое с чем нужно определится - какой аспект программы мы будем исследовать. 

Например, это может быть загрузка таблицы из памяти. Однако в основном хеш-таблица - это структура данных, которая долго живет в программе. И соответственно загрузка и удаление таблицы занимают заметно меньшее время по сравнению с временем жизни структуры. Поэтому оставим эти оптимизации вне круга нашей работы.

Вернемся к хеш-таблице из первой части.
Из-за большего количества коллизий поиск элемента становится затруднительным, так как высчитать хеш элемента уже недостаточно. Поэтому сфокусируемся на задаче поиска элемента.   

### **Тестирование**
Создадим тестовую ситуацию, когда мы ищем большое количество элементов в хеш-таблице. Для этого в цикле будем искать слова, которыми заполнена хеш-таблица.

Для просмотра затрачиваемых программой ресурсов будем использовать профайлер [Callgrind](https://habr.com/ru/articles/167837/)[^2], являющийся встроенным инструментом в утилиту [Valgrind](https://valgrind.org/)[^3].

Теперь посмотрим на статистику нашей программы (цифрами обозначается общее количество выполненых машинных инструкций):

<details>
<summary> Приложение 2. Статистика неоптимизированной версии тестирующей программы. </summary>

![callgring statisics without optimizations](resources/readme_pic/profiling_no_optimizations.png)

</details>
<br /> 

Из данной таблицы видно, что большая часть машинных инструкций уходит на вычисление хеша. Поэтому начнем оптимизации именно с этой функций.

#### **Оптимизация 1. Хеш-функция**
Начнем оптимизации с самой ресурсозатратной функции - функции хеширования, а именно `hash8_crc32_not_optimized`. 

В данной работе элементы - это слова. В начальной реализации базовым типом был массив символов. 
Однако слова удобно представлять в виде векторов, так как это позволяет работать со словом целиком, а не с каждым символом по отдельности. Поэтому перейдем от строки произвольной длины, к строке фиксированной длины.

Для оптимизации функции, высчитывающей хеш, возможны следующие действия:
1. Написать её на ассемблере,
2. Написать её на инлайн ассемблере (ассемблерная вставка),
3. Написать её на [интрисиках](https://github.com/ArsenySamoylov/Asm/tree/master/SIMD)[^4].

[Наша экспериментальная установка](#section-experimental-setup) имеет встроенную аппаратную поддержку хеширования crc32.
Так же экспериментальная установка имеет набор инструкции `AVX2`, позволяющий использовать вектор максимальной длиной до 32 байт, что более чем достаточно для наших исходных данных.
   
Реализуем все три вида оптимизированной функции хеширования и проанализируем их.

<details>
<summary> Реализации разных оптимизаций </summary>

Функция расчета хеша, написанная на ассемблере:
```
.global hash8_crc32_assembler

 hash8_crc32_assembler:
    cmp $0x0, %rdi
    je .end

    crc32q     (%rdi), %rax
    crc32q 0x08(%rdi), %rax 
    crc32q 0x10(%rdi), %rax 
    crc32q 0x18(%rdi), %rax

    .end:

    ret
```
С помощью инлайн-ассемблера:
```
index_t hash8_crc32_inline_as (const data* key)
    {
    int64_t res = 0;
    
    asm (
        R"(
         .intel_syntax noprefix
          cmp %1, 0x0
          je 1f
          
          xor %0, %0

          crc32 %0, qword ptr [%1 + 0x00 ]
          crc32 %0, qword ptr [%1 + 0x08 ]
          crc32 %0, qword ptr [%1 + 0x10 ]
          crc32 %0, qword ptr [%1 + 0x18 ]
        1:
       
        .att_syntax prefix
        )"
            : "=r"(res)
            : "r"(key), "r"(res) 
      );

    return (index_t) res;
    }
```
Через интринсики:
```
index_t hash8_crc32_intrinsics (const data* key)
    {
    __m256i element = _mm256_loadu_si256 (key);
    
    index_t hash = _mm_crc32_u32(0, _mm256_extract_epi64 (element, 0));
    
    hash = _mm_crc32_u32(hash, _mm256_extract_epi64 (element, 1));
    hash = _mm_crc32_u32(hash, _mm256_extract_epi64 (element, 2));
    hash = _mm_crc32_u32(hash, _mm256_extract_epi64 (element, 3));
    
    return hash;
    }
```
</details>

#### **Таблица 2.** Сравнение времени для разных реализаций функции хеширования.

Реализация функции       | Время тестирования, секунды
-------------------------|---------------------------------
`hash8_crc32_assembler`  | 29.0
`hash8_crc32_inline_as`  | 19.3
`hash8_crc32_intrinsics` | 15.7

Из таблицы видно, что функция на интринсиках показала лучший результат.

##### **Inline** 
Рассмотрим, как можно еще лучше оптимизировать функцию хеширования.

Функция расчета хеша достаточно компактна, поэтому компилятор может подставить ее напрямую в функцию вместо вызова, тем самым уменьшая количество инструкций. Посмотрим, как изменятся показателей функций, если сделать их инлайн версии.

Теперь замерим время для функции.

#### **Таблица 3.** Сравнение инлайн функций.
Функция                  | Время, секунды
-------------------------|---------------------------------
`hash8_crc32_assembler`  | 29.0
`hash8_crc32_inline_as`  | 19.0
`hash8_crc32_intrinsics` | 15.3

Используя опцию компилятора `save-temps` посмотрим, как компилятор  подставляет код:

Сгенерированный ассемблерный код для функции написанной на инлайн-ассемблере:

```
FindElementInHashTable:
          ...
         .intel_syntax noprefix
          cmp %rax, 0x0
          je 1f
          
          xor %rdi, %rdi

          crc32 %rdi, qword ptr [%rax + 0x00 ]
          crc32 %rdi, qword ptr [%rax + 0x08 ]
          crc32 %rdi, qword ptr [%rax + 0x10 ]
          crc32 %rdi, qword ptr [%rax + 0x18 ]
        1:
       
        .att_syntax prefix
        ...
```

Код для функции, использующей интринсики:

```
FindElementInHashTable:
        ...
        xorl    %eax, %eax
        crc32l  (%rdi), %eax
        crc32l  8(%rdi), %eax
        crc32l  16(%rdi), %eax
        crc32l  24(%rdi), %eax
        movl    %eax, -4(%rsp)
        xorl    %eax, %eax
        ...
```

Отсюда видно, что компилятор действительно подставил код вместо вызова функции.

Однако компилятор не может сделать это для функции, написанной на ассемблере.
```
FindElementInHashTable:
    ...
    call    hash8_crc32_assembler@PLT
    ...
```

Из этого можно сделать вывод, что при оптимизации лучше использовать ассемблерную вставку или интринсики вместо написания функции на чистом ассемблере.

Остановимся на выборе лучшей функции - использующей интринсики.
Замерим, на сколько изменилось время поиска:

#### **Таблица 4.** Результаты первой оптимизации.

Версия программы                | Время поиска, секунды | Абсолютный прирост | Относительный прирост
--------------------------------|-----------------------|--------------------|-----------------------
без оптимизаций                 | 29.3                  | -                  | -
первая оптимизация              | 15.3                  | 1.92               | 1.92

### **Оптимизация 2. Cравнения элементов**

Посмотри как изменилась статистика Callgrind`a.
<details> 
<summary> Приложение 3. Статистика приложения после первой оптимизаций.  </summary>

![callgring statisics with 1st otimization](resources/readme_pic/stat_befor_2_opt.png)

</details>
<br /> 

Оптимизируем функция сравнения строк.

Как показала предыдущая оптимизация наибольший прирост дает использование функции на интринсиках. Поэтому используем их для оптимизации.

<details> 
<summary> Функция сравнения на интринсиках </summary>

```
static inline int cmp_vectors (__m256i a, __m256i b)
    {
    __m256i pcmp = _mm256_cmpeq_epi8(a, b); 
    unsigned bitmask = (unsigned) _mm256_movemask_epi8(pcmp);
    
    return (bitmask == 0xffffffffU);
    }
```
</details>
<br /> 

#### **Таблица 5.** Результат второй оптимизации.
Версия программы                | Время поиска, секунды | Абсолютный прирост | Относительный прирост
--------------------------------|-----------------------|--------------------|-----------------------
без оптимизаций                 | 29.3                  | -                  | -
первая оптимизация              | 15.3                  | 1.92               | 1.92
вторая оптимизация              | 11.7                  | 2.50               | 1.31

### **Оптимизация 3. Проверки и деление**
Посмотрим, как теперь выглядит затраты функций.

<details> 
<summary> Приложение 4. Статистика приложения после первых второй оптимизации.  </summary>

![callgring statisics with otimizations](resources/readme_pic/profiling_before_3rd_opt.png)

</details>
<br /> 

Из графа видно, что значительную часть занимает функция `FindElementInList_optimized `, уже оптимизированная при замене функции сравнения строк. 

Посмотрим на исходник этой функции:

<details> 
<summary> Функция поиска элемента в контейнере </summary>

```
Node* FindElementInList (const List* list, const data* element)
    {
    assert(list);
    assert(element);

    if (list->number_of_elements == 0)
        return NULL;
    
    __m256i element_data = _mm256_load_si256 (element);
   
    Node* current_node = list->first_node;
    
    while (current_node)
        {
        __m256i current_node_data = _mm256_load_si256 (current_node->data_ptr); 
        
        if (cmp_vectors(current_node_data, element_data))
                return current_node;

        current_node = current_node->next;
        }
    
    return NULL;
    }
```
</details>

<br /> 

Инлайн функция `cmp_vectors` уже оптимизирована с помощью интринсиков. Поэтому единственный способ оптимизировать эту функцию, это поменять алгоритм поиска элемента внутри списка, что за рамками наших оптимизаций.

Посмотрим на исходники следующей по ресурсозатратности функции `FindElementInHashTable`:

<details> 
<summary> Функция поиска элемента в хеш-таблице </summary>

```
data* FindElementInHashTable (const HashTable* table, const data* element)
    {
    assert(table);
    assert(element);
    
    index_t hash_index = (hash8_crc32_itrinsics_inline(element)) 
                         % ((index_t) table->number_of_lists);
        
    Node* result = FindElementInList (table->list_array + hash_index, element);
    
    if (!result)
        return NULL;

    return result->data_ptr;
    }   
```

</details>
<br /> 

Так как это уже финальная версия программы, то можно отключить дополнительные проверки:
- `CheckList`, проверяющая структуру `List` (контейнер или список в наших терминах) на возможные ошибки,
- assert`ы.

#### **Таблица 6.** Промежуточные результат третьей оптимизации.
Версия программы                | Время поиска, секунды | Абсолютный прирост | Относительный прирост
--------------------------------|-----------------------|--------------------|-----------------------
без оптимизаций                 | 29.3                  | -                  | -
первая оптимизация              | 15.3                  | 1.92               | 1.92
вторая оптимизация              | 11.7                  | 2.50               | 1.31
вторая оптимизация без проверок | 11.2                  | 2.62               | 1.04

Последнее, что можно оптимизировать в этой функции - это операцию поиска остатка от деления. `table->number_of_lists` - задается константой времени компиляции, поэтому если вместо её использования подставить константу, то компилятор сможет оптимизировать нахождение остатка.

<details> 
<summary> Генерирующийся код для поиска остатка от деления </summary>

Код без использования константы:
```
FindElementInHashTable_crc32:
        ...
        xorl    %edx, %edx
        divl    240168(%rdi)
        xorl    %ebx, %ebx
        leaq    (%rdx,%rdx,2), %rax
        leaq    (%rdi,%rax,8), %rdi
        callq   FindElementInList 
        ...
```

Код с использованием константы:
```
FindElementInHashTable_crc32:
        ...
        imulq   $1757988013, %rax, %rcx         # imm = 0x68C8C4AD
        shrq    $44, %rcx
        imull   $10007, %ecx, %ecx              # imm = 0x2717
        subl    %ecx, %eax
        leaq    (%rax,%rax,2), %rax
        leaq    (%rdi,%rax,8), %rdi
        callq   FindElementInList
        ...
```
</details>

#### **Таблица 7.** Результат третьей оптимизации.
Версия программы                | Время поиска, секунды | Абсолютный прирост | Относительный прирост
--------------------------------|-----------------------|--------------------|-----------------------
без оптимизаций                 | 29.3                  | -                  | -
первая оптимизация              | 15.3                  | 1.92               | 1.92
вторая оптимизация              | 11.7                  | 2.50               | 1.31
вторая оптимизация без проверок | 11.2                  | 2.62               | 1.04
треть оптимизация               | 10.9                  | 2.69               | 1.03

### **Завершение оптимизаций**
Из статистики Callgrind`a виднo (красным зачеркнуты уже оптимизированные функции), что следующая по ресурсоемкости функция - это тестирующая функция, после которой идут уже функции из стандартной библиотеки.

<details> 
<summary> приложение 5. Графы вызовов функций </summary> 

![callgring final](resources/readme_pic/final_stat.png)
</details>

<br>
На этом закончим наши оптимизации.

#### **Таблица 8.** Итоги оптимизаций.
Абослютный прирост | Коэффицент ассемблерной оптимизации | Количество оптимизированных функций | Количество переписанных на интринсиках строк
-------------------|-------------------------------------|-------------------------------------|--------------------------------
2.69               | 179.3                               | 5                                   | 15

# Заключение
В ходе работы, мы изучили структуру данных - хеш-таблицу. Исследовали распределение восьми хеш-функций. И оптимизировали поиск в хеш-таблице.

## Ресурсы

[^1]: https://www.geeksforgeeks.org/implementing-our-own-hash-table-with-separate-chaining-in-java/?type=article&id=137749
[^2]: https://habr.com/ru/articles/167837/
[^3]: https://valgrind.org/
[^4]: https://github.com/ArsenySamoylov/Asm/tree/master/SIMD