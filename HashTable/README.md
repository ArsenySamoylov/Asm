# Введение
Это директория посвящена практическому изучению оптимизации производительности программы. Эта задача будет изучаться на примере структуры данных - хеш-таблицы. Данная работа состоит из двух частей. Первая нацелена на то, чтобы познакомиться со структурой данных - хеш-таблицей, и рассмотреть возможные оптимизации на абстрактном уровне алгоритма, на примере разных хеш-функций. Вторая часть направлена на поиск "узких мест" уже существующего алгоритма и их устранение.

# Цель работы
Основная цель этой работы - это научится правильно анализировать производительность программу и научиться **?оптимизировать как абстрактный алгоритм, так и конкретную реализацию?**

# Задачи
На примере структура данных, хеш-таблицы, сделать два уровня исследования и оптимизации.
На первом уровне анализируется абстрактный алгоритм работы хеш-функций, на втором уровне оптимизируется реализация выбранного алгоритма

# Гипотеза
Чтобы добиться хорошего результата работы программы нужно тщательно исследовать абстрактную модель и её реализацию.

# Теоретическое введение
Для выполнения поставленных целей и задач, как уже было сказано выше, была выбрана одна из стандартных и широко использующихся структур данных: хеш-таблица.
Что такое хеш-таблица?
...

# Ход работы

## Первая часть
Перед тем как начать анализировать абстрактную модель, нужно сначала понять, почему для работы была выбрана именно данная структура данных.

### Почему хеш-таблица?
Хеш-таблица была выбрана неспроста. Это достаточно популярная структура, которая находит широкое применение во всех областях программирования. Так же, хорошо подобранная модель хеш-таблицы имеет множество преимуществ в качестве способа хранения данных. Но у этой модели есть свои недостатки.
*Но какой же главный недостаток?*
Главный минус хеш-таблицы - это большое потребление памяти. Теоретически, эта структура позволяет поиск, добавление и другие операции с её элементами за асимптотическое время О(1). Однако, чтобы это было возможно, необходимо, чтобы каждый элемент имел свой отдельный контейнер. Это означает, что количество занимаемой памяти асимптотически оценивается как О(n), где n - количество элементов. Один из способов уменьшения количества памяти - это наличие коллизий (случаев когда двум разным ключам соответствует один контейнер). Хеш-таблицы считается хорошей, когда в среднем в каждом контейнере ~ 1.5-2 элемента.
Так же важно, что бы элементы были распределены равномерно.

### Постановка задач
Теперь, когда мы определили главные недостаток хеш-таблицы, можно сформулировать задачи для исследования в первой части.
Именно задача равномерного распределения и будет предметом нашего изучения в первой части работы.

### Модель для исследований
Так как это исследовательская работа, то мы можем позволить себе некоторые изменения модели.
Для хорошей репрезентативности мы будем симулировать ситуацию, когда элементов настолько много, что в каждом контейнере гораздо больше двух элементов. Данная ситуация позволять более отчетливо выявить неравномерность распределения элементов.
Для эксперимента будем добиваться условий, когда в каждом контейнере примерно 10-20 элементов. Для достижения этих параметров будем использовать два метода:
1. большое количество элементов для хранение в структуре данных
2. ограничения количества контейнеров
 
Для выполнения работы в качесве элементов выберем английские слова. В качестве базы данных возьмем произведение Вильяма Шекспира "Гамлет", в котором насчитается около 32 тысяч слов. Преимущество осмысленного в том, что в нем есть определенная закономерность распределения слов, что является важным, так как зачастую в любом массиве данных есть определенные паттерны и закономерности.
В хеш-таблице будут хранится только уникальные слова, которых в данном тексте 5178. Таким образом, наша цель - добится, чтобы в ? контейнерах в среднем было ? элементов.

### Измерения
Хеш-функция - это главный фактор, определяющий распределение элементов по контейнерам, так как именно она отвечает, в каком контейнере будем хранится элемент. Поэтому сфокусируемся на выборе хеш-функции. Выберем семь различных функций, которые каждому слову сопоставляют:
1. всегда еденицу
2. ASCII код первого символа
3. длину слова
4. сумму ASCII кодов всех символов


Так же используем еще три алгоритмические функции, в алгоритм которых мы не будем углубляться, так как это вне ?круга нашего исследования?. Для определенности их имена приведены ниже:
1. rol
2. ror
3. djb2

### Выводы из первой части

## Вторая часть

### А что делать теперь?
В первой части мы анализировали хеш-таблицу как абстрактную модель, не углубляясь в детали ее реализации. Теперь же займемся исследованием конкретной модели, реализованной для этой лабораторной работы.

Первое с чем нужно определится - это какой аспект программы мы будем исследовать. Например, это может быть загрузка таблицы из памяти. Однако исследование данного вопроса быстро привело бы нас к выводу, что производительность программы упираются в ограничения жесткого диска и самым рациональным методом оптимизации была бы покупка нового железа.
Подобные исследования не принесли бы большого исследовательского результата.

Вернемся к модели хеш-таблицы из первой части. Из-за большего количества коллизий поиск элемента становится затруднительным, так как высчитать хеш элемента уже недостаточно. Поэтому сфокусируемся на задаче поиска элемента.

### Измерения
Определившись с объектом нашего исследования, настроим установку так, чтобы с помощью профайлера (приложения, собирающие статистику по работе программы) можно было найти *критический путь* при поиске элемента.


# Заключение

