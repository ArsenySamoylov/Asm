Генерирующийся ассемблерный файл для данной программы \label{index_md_README}%
\Hypertarget{index_md_README}%
Данный репозиторий является продолжением моего проекта по созданию компилятора для собственного простого \href{https://github.com/ArsenySamoylov/Lang.git}{\texttt{ языка программирования}}. Данная часть посвящена Backend\`{}у для х86 архитектуры.\hypertarget{index_autotoc_md1}{}\doxysection{Следующая итерация}\label{index_autotoc_md1}
В контексте данной работы Backend -\/ это программа переводящая Абстрактно-\/синтаксическое дерево (AST) в код для {\ttfamily исполнителя}. В первой итерации работы {\ttfamily исполнителем} был написанной мной \href{https://github.com/ArsenySamoylov/CoreIArs.git}{\texttt{ Soft\+Cpu}}, который имеет стековую архитектуру и небольшую область памяти, а также может выполнять простые математические операции.

Главными изменениями в этой итерации стали\+:
\begin{DoxyItemize}
\item переход со стековой архитектуры на регистровую,
\item переход с виртуального исполнителя на физический (в данном случае это Intel Core i5-\/10300H 2.\+50\+GHz)
\item введение промежуточного представления программы -\/ IR код;
\end{DoxyItemize}

Начнем с IR кода.

Работа компилятора разделена на три части {\itshape front end}, {\itshape middle-\/end} и {\itshape backend}. Так как это независимые части, то между ними нужен общий вид передачи программы. В предыдущей итерации в этой роли выступало AST дерево и разработанный нашей учебной группой специальный \href{https://github.com/dodokek/LanguageStandart.git}{\texttt{ стандарт}} его хранения. Однако AST дерево слишком не похоже на машинную реализацию программы и соответственно большая часть задачи по оптимизации перекладываются на Backend, что рушит смысл разделения компилятора на три части.

Поэтому возникает необходимость в промежуточном представлении программы, которое больше бы походило на машинный код.

Так как мы переходим на регистровую архитектуру, то будем ориентироваться на уже готовые решения в этом направлении. Самым известным и распространённым решением является IR от \href{https://llvm.org/docs/LangRef.html}{\texttt{ LLVM\`{} a}}.

Взяв его за основу, я реализовал собственный простейший IR. Если это проект получит продолжение, то следующей итерацией будет переход на полноценное использование IR от LLVM.

{\bfseries{Замечание\+:}} Я решил сделать собственную реализацию простейшего IR в учебных целях. Дальнейшее его развитие, на данный момент, не имеет смыслы =(.\hypertarget{index_autotoc_md2}{}\doxysubsection{Описание моего IR\`{}a}\label{index_autotoc_md2}
IR реализован с помощью классов и наследования на языке {\ttfamily C++}.

Основной выступает абстрактный класс {\ttfamily \mbox{\hyperlink{class_value}{Value}}}, который хранит {\ttfamily name} -\/ имя объекта (так же \mbox{\hyperlink{class_value}{Value}} хранит константу -\/ тип конкретного объекта, что на самом деле является излишним; однако я решил оставить поле, так как это может пригодиться при отладке программы). От этого абстрактного класса наследуются классы\+:
\begin{DoxyItemize}
\item {\ttfamily \mbox{\hyperlink{class_constant}{Constant}}} -\/ константа, хранит число,
\item {\ttfamily \mbox{\hyperlink{class_global_var}{Global\+Var}}} -\/ глобальная переменная, хранит указатель на {\ttfamily \mbox{\hyperlink{class_constant}{Constant}}} -\/ начальное значение переменной,
\item {\ttfamily \mbox{\hyperlink{class_instruction}{Instruction}}} -\/ абстрактный класс инструкций, которые выполняются исполнителем;
\item {\ttfamily \mbox{\hyperlink{class_base_block}{Base\+Block}}} -\/ массив {\ttfamily \mbox{\hyperlink{class_instruction}{Instruction}}} {\ttfamily ов, которые должны выполняться последовательно (подробнее об этом будет написано позже), -\/}\mbox{\hyperlink{class_function}{Function}}{\ttfamily -\/ функция, хранит массив}Base\+Blockов,
\end{DoxyItemize}

Данная иерархия описана в файле \href{src/IR/Value/Value.h}{\texttt{ {\ttfamily src/\+IR/\+Value/\+Value.\+h}}}.

Как было написано выше {\ttfamily \mbox{\hyperlink{class_instruction}{Instruction}}} -\/ это абстрактный класс, от которого наследуются классы\+:
\begin{DoxyItemize}
\item {\ttfamily \mbox{\hyperlink{class_store}{Store}}} -\/ инструкция выделения памяти для объекта {\ttfamily \mbox{\hyperlink{class_value}{Value}}}, хранит указатель на {\ttfamily \mbox{\hyperlink{class_value}{Value}}},
\item {\ttfamily \mbox{\hyperlink{class_load}{Load}}} -\/ инструкция загрузи {\ttfamily \mbox{\hyperlink{class_value}{Value}}} в память, хранит указатели на источник (src) и приемник (dest),
\item {\ttfamily \mbox{\hyperlink{struct_operator}{Operator}}} -\/ математический или логическая операция, хранит указатели на операнды,
\item {\ttfamily \mbox{\hyperlink{class_branch}{Branch}}} -\/ инструкция передачи контроля, хранит указатель на условие и два указателя на базовые блоки (ветки); в соответствии c условием выбирается один из двух базовых блоков (веток), которому перейдет контроль выполнения программы ({\itshape замечание}\+: {\ttfamily \mbox{\hyperlink{class_branch}{Branch}}} это более удобный аналог инструкции {\ttfamily jmp}),
\item {\ttfamily \mbox{\hyperlink{class_call}{Call}}} -\/ вызов функции, хранит имя вызываемой функции и аргументы,
\item {\ttfamily \mbox{\hyperlink{struct_return}{Return}}} -\/ инструкция возврата из функции, хранит указатель на возвращаемое значение.
\end{DoxyItemize}

Данная иерархия описана в файле \href{src/IR/Instructions/Instructions.h}{\texttt{ {\ttfamily srs/\+IR/\+Instructions/\+Instructions.\+h}}}.

Класс {\ttfamily \mbox{\hyperlink{class_module}{Module}}}, определенный в \href{src/IR/Module/Module.h}{\texttt{ {\ttfamily src/\+IR/\+Module/\+Module.\+h}}}, является массивом объектов {\ttfamily \mbox{\hyperlink{class_function}{Function}}} и {\ttfamily \mbox{\hyperlink{class_global_var}{Global\+Var}}}. Объект {\ttfamily \mbox{\hyperlink{class_module}{Module}}} представляет собой исходную программу на моем языке.\hypertarget{index_autotoc_md3}{}\doxysubsubsection{Иерархии классов в IR\`{}e}\label{index_autotoc_md3}
 \hypertarget{index_autotoc_md4}{}\doxysubsubsection{Module в IR\`{}e}\label{index_autotoc_md4}
 

Как было сказано выше -\/ базовые блоки ({\ttfamily \mbox{\hyperlink{class_base_block}{Base\+Block}}}) это массив инструкций, которые будут выполняться последовательно. Каждый базовый блок заканчивается инструкций передающей контроль -\/ {\ttfamily \mbox{\hyperlink{struct_return}{Return}}} или {\ttfamily \mbox{\hyperlink{class_branch}{Branch}}}. Благодаря последовательному исполнению инструкций возможно оптимально распределять регистры внутри базового блока.

Однако существует проблема оптимизации использования регистров между базовыми блоками. Это проблема достаточна сложна, поэтому мы не будем рассматривать её в данной итерации проекта.\hypertarget{index_autotoc_md5}{}\doxysubsection{Пример}\label{index_autotoc_md5}
Рассмотрим пример простой программы на моем языке. Программа высчитывает факториал от заданной константы\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{double factorial (var number)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{    if (number > 1)}
\DoxyCodeLine{        return number * factorial (number -\/ 1);}
\DoxyCodeLine{    }
\DoxyCodeLine{    return 1;}
\DoxyCodeLine{    \} }
\DoxyCodeLine{    }
\DoxyCodeLine{double main ()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{    var result = factorial (6); }
\DoxyCodeLine{    fout << result;}
\DoxyCodeLine{    }
\DoxyCodeLine{    return 0;}
\DoxyCodeLine{    \}}

\end{DoxyCode}


Её {\ttfamily IR} представление\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{extern function 'fout' ();}
\DoxyCodeLine{}
\DoxyCodeLine{Declare function 'factorial' (param number):}
\DoxyCodeLine{entry\_factorial:}
\DoxyCodeLine{    \%op\_0 = bigger number, 1}
\DoxyCodeLine{    br \%op\_0, label than\_0, label merge\_0}
\DoxyCodeLine{}
\DoxyCodeLine{than\_0:}
\DoxyCodeLine{    \%op\_2 = sub number, 1}
\DoxyCodeLine{    \%c\_1 = call: factorial (param \%op\_2)}
\DoxyCodeLine{    \%op\_3 = mul number, \%c\_1}
\DoxyCodeLine{}
\DoxyCodeLine{    return \%op\_3}
\DoxyCodeLine{    br label merge\_0}
\DoxyCodeLine{}
\DoxyCodeLine{merge\_0:}
\DoxyCodeLine{}
\DoxyCodeLine{    return 1}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{Declare function 'main' ():}
\DoxyCodeLine{entry\_main:}
\DoxyCodeLine{    \%c\_0 = call: factorial (param 6)}
\DoxyCodeLine{    result = store(\%c\_0)}
\DoxyCodeLine{    call: fout (param result)}
\DoxyCodeLine{}
\DoxyCodeLine{    return 0}

\end{DoxyCode}
 Здесь {\ttfamily declare} обозначает начало определения функции, метка -\/ начало базового блока.

Каждая инструкция представляет собой переменную, которая может дальше использовать программой. Данный синтаксис призван подчеркнуть это, например\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\%op\_2 = sub number, 1}
\DoxyCodeLine{\%c\_1 = call: factorial (param \%op\_2)}

\end{DoxyCode}
 Здесь {\ttfamily op\+\_\+2} -\/ это результат разности является переменной, служащий аргументом для {\ttfamily call} a. А {\ttfamily c\+\_\+1} -\/ это переменная хранящая возвращаемое значение вызова (если функция ничего не возвращает, то присваивание переменой опускается, как в строчке с вызовом {\ttfamily fout}).

При генерации исполняемого файла так же генерируется ассемблерный файл, подробно расписывающий как происходила генерация машинных команд. Это файл компилируется и сохраняет логику программы. С его помощью легко можно создать контрольный исполняемый файл, который помогает проверять правильность генерации машинных кодов.

Для удобства, в ассемблерном файле печатается исходная строчка из IR{\ttfamily a в виде комментария (строки начинающиеся с}\#\#\#\`{}), после чего идет ассемблерная реализация данной строчки.

{\bfseries{Замечание\+:}}

Исходная итерация имела особенность\+: исполнитель работал с вещественными числами заданной точностью, храня их в виде целых чисел. Для этого число умножается на константу {\ttfamily PRECISION} (в данном случае равной 100). Данная итерация унаследовала эту особенность. Поэтому например при умножении двух чисел результат нормируется\+: делится на 100.

$<$details$>$


\begin{DoxyCode}{0}
\DoxyCodeLine{    .global main}
\DoxyCodeLine{    .extern fout}
\DoxyCodeLine{}
\DoxyCodeLine{    .section .text}
\DoxyCodeLine{\_start:}
\DoxyCodeLine{    call main }
\DoxyCodeLine{    movq \$0   , \%rdi      }
\DoxyCodeLine{    movq \$60  , \%rax      }
\DoxyCodeLine{    syscall}
\DoxyCodeLine{}
\DoxyCodeLine{factorial:}
\DoxyCodeLine{    \# set stack frame (1 local vars)}
\DoxyCodeLine{    sub \$8, \%rsp }
\DoxyCodeLine{    push \%rbp     }
\DoxyCodeLine{    mov \%rsp,   \%rbp      }
\DoxyCodeLine{}
\DoxyCodeLine{    \# save callee-\/save regs}
\DoxyCodeLine{    push \%rbx     }
\DoxyCodeLine{    push \%r10     }
\DoxyCodeLine{    push \%r11     }
\DoxyCodeLine{    push \%r12     }
\DoxyCodeLine{    push \%r13     }
\DoxyCodeLine{    push \%r14     }
\DoxyCodeLine{    push \%r15     }
\DoxyCodeLine{}
\DoxyCodeLine{    \# save param regs on stack}
\DoxyCodeLine{    movq \%rdi, -\/8 (\%rbp)  \# Save 'number' on stack}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{entry\_factorial:}
\DoxyCodeLine{\#\#\# \%op\_0 = bigger number, 1}
\DoxyCodeLine{    movq \$100 , \%r15      \# put\_value\_to\_reg: ' const\_0' -\/> \%r15}
\DoxyCodeLine{                          \# put\_value\_to\_reg: 'number' already in \%rdi}
\DoxyCodeLine{}
\DoxyCodeLine{    mov \%rdi,   \%r14      \# save 'number' to \%r14}
\DoxyCodeLine{}
\DoxyCodeLine{    \# (generating logic op) \#}
\DoxyCodeLine{    push \%rdx     \# (save \%rdx)}
\DoxyCodeLine{}
\DoxyCodeLine{    cmpq \%r15, \%rdi}
\DoxyCodeLine{    setg \%al}
\DoxyCodeLine{    movzbq \%al, \%rax}
\DoxyCodeLine{}
\DoxyCodeLine{    \# (normalize result) \#}
\DoxyCodeLine{    xor \%rdx, \%rdx}
\DoxyCodeLine{    movq \$100 , \%rdi      }
\DoxyCodeLine{    imul \%rdi}
\DoxyCodeLine{    mov \%rax,   \%rdi      \# (-\/> normalized result)}
\DoxyCodeLine{}
\DoxyCodeLine{    pop \%rdx              \# (restore \%rdx)}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# br \%op\_0, label than\_0, label merge\_0}
\DoxyCodeLine{                          \# put\_value\_to\_reg: '\%op\_0' already in \%rdi}
\DoxyCodeLine{    cmp \$100, \%rdi}
\DoxyCodeLine{    je than\_0 }
\DoxyCodeLine{    jmp merge\_0 }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{than\_0:}
\DoxyCodeLine{\#\#\# \%op\_2 = sub number, 1}
\DoxyCodeLine{    movq \$100 , \%rdi      \# put\_value\_to\_reg: ' const\_1' -\/> \%rdi}
\DoxyCodeLine{                          \# put\_value\_to\_reg: 'number' already in \%r14}
\DoxyCodeLine{}
\DoxyCodeLine{    mov \%r14,   \%r15      \# save 'number' to \%r15}
\DoxyCodeLine{}
\DoxyCodeLine{    \# (math op) \#}
\DoxyCodeLine{    sub \%rdi, \%r14}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# \%c\_1 = call: factorial (param \%op\_2)}
\DoxyCodeLine{    \# (save busy regs) \#}
\DoxyCodeLine{    \# (set parameters) \# }
\DoxyCodeLine{    mov \%r14,   \%rdi      }
\DoxyCodeLine{    call factorial }
\DoxyCodeLine{    mov \%rax,   \%rdi      \# save call result from rax}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# \%op\_3 = mul number, \%c\_1}
\DoxyCodeLine{                          \# put\_value\_to\_reg: '\%c\_1' already in \%rdi}
\DoxyCodeLine{                          \# put\_value\_to\_reg: 'number' already in \%r15}
\DoxyCodeLine{}
\DoxyCodeLine{    mov \%r15,   \%r14      \# save 'number' to \%r14}
\DoxyCodeLine{}
\DoxyCodeLine{    \# (generating mul/div)\#}
\DoxyCodeLine{    push \%rdx             \# (save \%rdx)}
\DoxyCodeLine{    xor \%rdx, \%rdx}
\DoxyCodeLine{    mov \%r15,   \%rax      }
\DoxyCodeLine{    imul \%rdi}
\DoxyCodeLine{}
\DoxyCodeLine{    \# (normalize result)  \#}
\DoxyCodeLine{    xor \%rdx, \%rdx}
\DoxyCodeLine{    movq \$100 , \%r15      }
\DoxyCodeLine{    idiv \%r15}
\DoxyCodeLine{    mov \%rax,   \%r15      \# (-\/> normalized result)}
\DoxyCodeLine{}
\DoxyCodeLine{    pop \%rdx              \# (restore \%rdx)}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# return \%op\_3}
\DoxyCodeLine{    }
\DoxyCodeLine{    mov \%r15,   \%rax      \# return \%op\_3}
\DoxyCodeLine{    }
\DoxyCodeLine{    \# (restore callee-\/save regs)}
\DoxyCodeLine{    pop \%r15              }
\DoxyCodeLine{    pop \%r14              }
\DoxyCodeLine{    pop \%r13              }
\DoxyCodeLine{    pop \%r12              }
\DoxyCodeLine{    pop \%r11              }
\DoxyCodeLine{    pop \%r10              }
\DoxyCodeLine{    pop \%rbx              }
\DoxyCodeLine{}
\DoxyCodeLine{    \# (clear stack frame)}
\DoxyCodeLine{    pop \%rbp              }
\DoxyCodeLine{    add \$8, \%rsp }
\DoxyCodeLine{    ret }
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# br label merge\_0}
\DoxyCodeLine{    jmp merge\_0 }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{merge\_0:}
\DoxyCodeLine{\#\#\# return 1}
\DoxyCodeLine{    }
\DoxyCodeLine{    movq \$100 , \%rax      \# return const\_2}
\DoxyCodeLine{    \# restore callee-\/save regs}
\DoxyCodeLine{    pop \%r15              }
\DoxyCodeLine{    pop \%r14              }
\DoxyCodeLine{    pop \%r13              }
\DoxyCodeLine{    pop \%r12              }
\DoxyCodeLine{    pop \%r11              }
\DoxyCodeLine{    pop \%r10              }
\DoxyCodeLine{    pop \%rbx              }
\DoxyCodeLine{}
\DoxyCodeLine{    \# clear stack frame}
\DoxyCodeLine{    pop \%rbp              }
\DoxyCodeLine{    add \$8, \%rsp }
\DoxyCodeLine{    ret }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{main:}
\DoxyCodeLine{    \# set stack frame (1 local vars)}
\DoxyCodeLine{    sub \$8, \%rsp }
\DoxyCodeLine{    push \%rbp     }
\DoxyCodeLine{    mov \%rsp,   \%rbp      }
\DoxyCodeLine{}
\DoxyCodeLine{    \# save callee-\/save regs}
\DoxyCodeLine{    push \%rbx     }
\DoxyCodeLine{    push \%r10     }
\DoxyCodeLine{    push \%r11     }
\DoxyCodeLine{    push \%r12     }
\DoxyCodeLine{    push \%r13     }
\DoxyCodeLine{    push \%r14     }
\DoxyCodeLine{    push \%r15     }
\DoxyCodeLine{}
\DoxyCodeLine{    \# save param regs on stack}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{entry\_main:}
\DoxyCodeLine{\#\#\# \%c\_0 = call: factorial (param 6)}
\DoxyCodeLine{    \# save busy regs}
\DoxyCodeLine{    \# set parameters }
\DoxyCodeLine{}
\DoxyCodeLine{    movq \$600 , \%rdi      }
\DoxyCodeLine{    call factorial }
\DoxyCodeLine{    mov \%rax,   \%rdi      \# save call result from rax}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# result = store(\%c\_0)}
\DoxyCodeLine{                          \# put\_value\_to\_reg: '\%c\_0' already in \%rdi}
\DoxyCodeLine{    movq \%rdi, -\/8 (\%rbp)  \# copy '\%c\_0' to stack (to 'result')}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# call: fout (param result)}
\DoxyCodeLine{    \# save busy regs}
\DoxyCodeLine{    push \%rdi     \# save: \%c\_0}
\DoxyCodeLine{    \# set parameters }
\DoxyCodeLine{    movq -\/8 (\%rbp), \%rdi  }
\DoxyCodeLine{    call fout }
\DoxyCodeLine{    pop \%rdi              }
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# return 0}
\DoxyCodeLine{    }
\DoxyCodeLine{    movq \$0   , \%rax      \# return const\_1}
\DoxyCodeLine{    \# restore callee-\/save regs}
\DoxyCodeLine{    pop \%r15              }
\DoxyCodeLine{    pop \%r14              }
\DoxyCodeLine{    pop \%r13              }
\DoxyCodeLine{    pop \%r12              }
\DoxyCodeLine{    pop \%r11              }
\DoxyCodeLine{    pop \%r10              }
\DoxyCodeLine{    pop \%rbx              }
\DoxyCodeLine{}
\DoxyCodeLine{    \# clear stack frame}
\DoxyCodeLine{    pop \%rbp              }
\DoxyCodeLine{    add \$8, \%rsp }
\DoxyCodeLine{    ret }

\end{DoxyCode}


$<$/details$>$\hypertarget{index_autotoc_md6}{}\doxysubsection{Стандартная библиотека}\label{index_autotoc_md6}
Для полноценной использования языка необходима библиотека, реализующая простейшие стандартные функции. Моя реализация некоторых функций находится в файле {\ttfamily src/\+Elf/stdlib.\+s}. Машинный код стандартных функций берется из файла {\ttfamily src/\+Elf/stdlib.\+o} и добавляется в конец исполняемого файла.

Для создания контрольной программы с помощью генерирующегося ассемблерного кода, нужно линковать {\ttfamily src/\+Elf/stdlib.\+o}.\hypertarget{index_autotoc_md7}{}\doxysection{Итог\+:}\label{index_autotoc_md7}
В завершении работы замерим, как изменилось время работы программы на моем языке. Для сравнения будем использовать пример факториала из данной работы, но без вывода результата.\hypertarget{index_autotoc_md8}{}\doxysubsubsection{Таблица\+: время расчета факториала от 15, 1000 раз}\label{index_autotoc_md8}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Исполнитель   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Время, мс   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Коэффициент прироста    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Исполнитель   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Время, мс   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Коэффициент прироста    }\\\cline{1-3}
\endhead
Soft\+Cpu   &70   &-\/    \\\cline{1-3}
core i5   &1.\+2   &56.\+6   \\\cline{1-3}
\end{longtabu}


Получается, что в новой итерации исполнение программы ускорилось более чем в 50 раз! Хороший показатель (спасибо ребятам из {\itshape Intel} за такой мощный процессор ;)). 