<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_mainpage" xml:lang="en-US">

<para>Генерирующийся ассемблерный файл для данной программы <anchor xml:id="_index_1md_README"/>Данный репозиторий является продолжением моего проекта по созданию компилятора для собственного простого <link xlink:href="https://github.com/ArsenySamoylov/Lang.git">языка программирования</link>. Данная часть посвящена Backend`у для х86 архитектуры.</para>
<section xml:id="_index_1autotoc_md1">
<title>Следующая итерация</title>

<para>В контексте данной работы Backend - это программа переводящая Абстрактно-синтаксическое дерево (AST) в код для <computeroutput>исполнителя</computeroutput>. В первой итерации работы <computeroutput>исполнителем</computeroutput> был написанной мной <link xlink:href="https://github.com/ArsenySamoylov/CoreIArs.git">SoftCpu</link>, который имеет стековую архитектуру и небольшую область памяти, а также может выполнять простые математические операции.</para>

<para>Главными изменениями в этой итерации стали:<itemizedlist>
<listitem>
<para>переход со стековой архитектуры на регистровую,</para>
</listitem><listitem>
<para>переход с виртуального исполнителя на физический (в данном случае это Intel Core i5-10300H 2.50GHz)</para>
</listitem><listitem>
<para>введение промежуточного представления программы - IR код;</para>
</listitem></itemizedlist>
</para>

<para>Начнем с IR кода.</para>

<para>Работа компилятора разделена на три части <emphasis>front end</emphasis>, <emphasis>middle-end</emphasis> и <emphasis>backend</emphasis>. Так как это независимые части, то между ними нужен общий вид передачи программы. В предыдущей итерации в этой роли выступало AST дерево и разработанный нашей учебной группой специальный <link xlink:href="https://github.com/dodokek/LanguageStandart.git">стандарт</link> его хранения. Однако AST дерево слишком не похоже на машинную реализацию программы и соответственно большая часть задачи по оптимизации перекладываются на Backend, что рушит смысл разделения компилятора на три части.</para>

<para>Поэтому возникает необходимость в промежуточном представлении программы, которое больше бы походило на машинный код.</para>

<para>Так как мы переходим на регистровую архитектуру, то будем ориентироваться на уже готовые решения в этом направлении. Самым известным и распространённым решением является IR от <link xlink:href="https://llvm.org/docs/LangRef.html">LLVM` a</link>.</para>

<para>Взяв его за основу, я реализовал собственный простейший IR. Если это проект получит продолжение, то следующей итерацией будет переход на полноценное использование IR от LLVM.</para>

<para><emphasis role="bold">Замечание:</emphasis> Я решил сделать собственную реализацию простейшего IR в учебных целях. Дальнейшее его развитие, на данный момент, не имеет смыслы =(.</para>
<section xml:id="_index_1autotoc_md2">
<title>Описание моего IR`a</title>

<para>IR реализован с помощью классов и наследования на языке <computeroutput>C++</computeroutput>.</para>

<para>Основной выступает абстрактный класс <computeroutput><link linkend="_class_value">Value</link></computeroutput>, который хранит <computeroutput>name</computeroutput> - имя объекта (так же <link linkend="_class_value">Value</link> хранит константу - тип конкретного объекта, что на самом деле является излишним; однако я решил оставить поле, так как это может пригодиться при отладке программы). От этого абстрактного класса наследуются классы:<itemizedlist>
<listitem>
<para><computeroutput><link linkend="_class_constant">Constant</link></computeroutput> - константа, хранит число,</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_global_var">GlobalVar</link></computeroutput> - глобальная переменная, хранит указатель на <computeroutput><link linkend="_class_constant">Constant</link></computeroutput> - начальное значение переменной,</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_instruction">Instruction</link></computeroutput> - абстрактный класс инструкций, которые выполняются исполнителем;</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_base_block">BaseBlock</link></computeroutput> - массив <computeroutput><link linkend="_class_instruction">Instruction</link></computeroutput> <computeroutput>ов, которые должны выполняться последовательно (подробнее об этом будет написано позже), -</computeroutput><link linkend="_class_function">Function</link><computeroutput>- функция, хранит массив</computeroutput>BaseBlockов,</para>
</listitem></itemizedlist>
</para>

<para>Данная иерархия описана в файле <link xlink:href="src/IR/Value/Value.h"><computeroutput>src/IR/Value/Value.h</computeroutput></link>.</para>

<para>Как было написано выше <computeroutput><link linkend="_class_instruction">Instruction</link></computeroutput> - это абстрактный класс, от которого наследуются классы:<itemizedlist>
<listitem>
<para><computeroutput><link linkend="_class_store">Store</link></computeroutput> - инструкция выделения памяти для объекта <computeroutput><link linkend="_class_value">Value</link></computeroutput>, хранит указатель на <computeroutput><link linkend="_class_value">Value</link></computeroutput>,</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_load">Load</link></computeroutput> - инструкция загрузи <computeroutput><link linkend="_class_value">Value</link></computeroutput> в память, хранит указатели на источник (src) и приемник (dest),</para>
</listitem><listitem>
<para><computeroutput><link linkend="_struct_operator">Operator</link></computeroutput> - математический или логическая операция, хранит указатели на операнды,</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_branch">Branch</link></computeroutput> - инструкция передачи контроля, хранит указатель на условие и два указателя на базовые блоки (ветки); в соответствии c условием выбирается один из двух базовых блоков (веток), которому перейдет контроль выполнения программы (<emphasis>замечание</emphasis>: <computeroutput><link linkend="_class_branch">Branch</link></computeroutput> это более удобный аналог инструкции <computeroutput>jmp</computeroutput>),</para>
</listitem><listitem>
<para><computeroutput><link linkend="_class_call">Call</link></computeroutput> - вызов функции, хранит имя вызываемой функции и аргументы,</para>
</listitem><listitem>
<para><computeroutput><link linkend="_struct_return">Return</link></computeroutput> - инструкция возврата из функции, хранит указатель на возвращаемое значение.</para>
</listitem></itemizedlist>
</para>

<para>Данная иерархия описана в файле <link xlink:href="src/IR/Instructions/Instructions.h"><computeroutput>srs/IR/Instructions/Instructions.h</computeroutput></link>.</para>

<para>Класс <computeroutput><link linkend="_class_module">Module</link></computeroutput>, определенный в <link xlink:href="src/IR/Module/Module.h"><computeroutput>src/IR/Module/Module.h</computeroutput></link>, является массивом объектов <computeroutput><link linkend="_class_function">Function</link></computeroutput> и <computeroutput><link linkend="_class_global_var">GlobalVar</link></computeroutput>. Объект <computeroutput><link linkend="_class_module">Module</link></computeroutput> представляет собой исходную программу на моем языке.</para>
<section xml:id="_index_1autotoc_md3">
<title>Иерархии классов в IR`e</title>

<para> </para>
</section>
<section xml:id="_index_1autotoc_md4">
<title>Module в IR`e</title>

<para> </para>

<para>Как было сказано выше - базовые блоки (<computeroutput><link linkend="_class_base_block">BaseBlock</link></computeroutput>) это массив инструкций, которые будут выполняться последовательно. Каждый базовый блок заканчивается инструкций передающей контроль - <computeroutput><link linkend="_struct_return">Return</link></computeroutput> или <computeroutput><link linkend="_class_branch">Branch</link></computeroutput>. Благодаря последовательному исполнению инструкций возможно оптимально распределять регистры внутри базового блока.</para>

<para>Однако существует проблема оптимизации использования регистров между базовыми блоками. Это проблема достаточна сложна, поэтому мы не будем рассматривать её в данной итерации проекта.</para>
</section>
</section>
<section xml:id="_index_1autotoc_md5">
<title>Пример</title>

<para>Рассмотрим пример простой программы на моем языке. Программа высчитывает факториал от заданной константы:</para>

<para><literallayout><computeroutput>double&#32;factorial&#32;(var&#32;number)
&#32;&#32;&#32;&#32;{
&#32;&#32;&#32;&#32;if&#32;(number&#32;&gt;&#32;1)
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return&#32;number&#32;*&#32;factorial&#32;(number&#32;-&#32;1);
&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;return&#32;1;
&#32;&#32;&#32;&#32;}&#32;
&#32;&#32;&#32;&#32;
double&#32;main&#32;()
&#32;&#32;&#32;&#32;{
&#32;&#32;&#32;&#32;var&#32;result&#32;=&#32;factorial&#32;(6);&#32;
&#32;&#32;&#32;&#32;fout&#32;&lt;&lt;&#32;result;
&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;return&#32;0;
&#32;&#32;&#32;&#32;}
</computeroutput></literallayout></para>

<para>Её <computeroutput>IR</computeroutput> представление: <literallayout><computeroutput>extern&#32;function&#32;&apos;fout&apos;&#32;();

Declare&#32;function&#32;&apos;factorial&apos;&#32;(param&#32;number):
entry_factorial:
&#32;&#32;&#32;&#32;%op_0&#32;=&#32;bigger&#32;number,&#32;1
&#32;&#32;&#32;&#32;br&#32;%op_0,&#32;label&#32;than_0,&#32;label&#32;merge_0

than_0:
&#32;&#32;&#32;&#32;%op_2&#32;=&#32;sub&#32;number,&#32;1
&#32;&#32;&#32;&#32;%c_1&#32;=&#32;call:&#32;factorial&#32;(param&#32;%op_2)
&#32;&#32;&#32;&#32;%op_3&#32;=&#32;mul&#32;number,&#32;%c_1

&#32;&#32;&#32;&#32;return&#32;%op_3
&#32;&#32;&#32;&#32;br&#32;label&#32;merge_0

merge_0:

&#32;&#32;&#32;&#32;return&#32;1


Declare&#32;function&#32;&apos;main&apos;&#32;():
entry_main:
&#32;&#32;&#32;&#32;%c_0&#32;=&#32;call:&#32;factorial&#32;(param&#32;6)
&#32;&#32;&#32;&#32;result&#32;=&#32;store(%c_0)
&#32;&#32;&#32;&#32;call:&#32;fout&#32;(param&#32;result)

&#32;&#32;&#32;&#32;return&#32;0
</computeroutput></literallayout> Здесь <computeroutput>declare</computeroutput> обозначает начало определения функции, метка - начало базового блока.</para>

<para>Каждая инструкция представляет собой переменную, которая может дальше использовать программой. Данный синтаксис призван подчеркнуть это, например:</para>

<para><literallayout><computeroutput>%op_2&#32;=&#32;sub&#32;number,&#32;1
%c_1&#32;=&#32;call:&#32;factorial&#32;(param&#32;%op_2)
</computeroutput></literallayout> Здесь <computeroutput>op_2</computeroutput> - это результат разности является переменной, служащий аргументом для <computeroutput>call</computeroutput> a. А <computeroutput>c_1</computeroutput> - это переменная хранящая возвращаемое значение вызова (если функция ничего не возвращает, то присваивание переменой опускается, как в строчке с вызовом <computeroutput>fout</computeroutput>).</para>

<para>При генерации исполняемого файла так же генерируется ассемблерный файл, подробно расписывающий как происходила генерация машинных команд. Это файл компилируется и сохраняет логику программы. С его помощью легко можно создать контрольный исполняемый файл, который помогает проверять правильность генерации машинных кодов.</para>

<para>Для удобства, в ассемблерном файле печатается исходная строчка из IR<computeroutput>a в виде комментария (строки начинающиеся с</computeroutput>###`), после чего идет ассемблерная реализация данной строчки.</para>

<para><emphasis role="bold">Замечание:</emphasis></para>

<para>Исходная итерация имела особенность: исполнитель работал с вещественными числами заданной точностью, храня их в виде целых чисел. Для этого число умножается на константу <computeroutput>PRECISION</computeroutput> (в данном случае равной 100). Данная итерация унаследовала эту особенность. Поэтому например при умножении двух чисел результат нормируется: делится на 100.</para>

<para>&lt;details&gt;</para>

<para><literallayout><computeroutput>&#32;&#32;&#32;&#32;.global&#32;main
&#32;&#32;&#32;&#32;.extern&#32;fout

&#32;&#32;&#32;&#32;.section&#32;.text
_start:
&#32;&#32;&#32;&#32;call&#32;main&#32;
&#32;&#32;&#32;&#32;movq&#32;$0&#32;&#32;&#32;,&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;movq&#32;$60&#32;&#32;,&#32;%rax&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;syscall

factorial:
&#32;&#32;&#32;&#32;#&#32;set&#32;stack&#32;frame&#32;(1&#32;local&#32;vars)
&#32;&#32;&#32;&#32;sub&#32;$8,&#32;%rsp&#32;
&#32;&#32;&#32;&#32;push&#32;%rbp&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;mov&#32;%rsp,&#32;&#32;&#32;%rbp&#32;&#32;&#32;&#32;&#32;&#32;

&#32;&#32;&#32;&#32;#&#32;save&#32;callee-save&#32;regs
&#32;&#32;&#32;&#32;push&#32;%rbx&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r10&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r11&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r12&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r13&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r14&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r15&#32;&#32;&#32;&#32;&#32;

&#32;&#32;&#32;&#32;#&#32;save&#32;param&#32;regs&#32;on&#32;stack
&#32;&#32;&#32;&#32;movq&#32;%rdi,&#32;-8&#32;(%rbp)&#32;&#32;#&#32;Save&#32;&apos;number&apos;&#32;on&#32;stack


entry_factorial:
###&#32;%op_0&#32;=&#32;bigger&#32;number,&#32;1
&#32;&#32;&#32;&#32;movq&#32;$100&#32;,&#32;%r15&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;&#32;const_0&apos;&#32;-&gt;&#32;%r15
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;number&apos;&#32;already&#32;in&#32;%rdi

&#32;&#32;&#32;&#32;mov&#32;%rdi,&#32;&#32;&#32;%r14&#32;&#32;&#32;&#32;&#32;&#32;#&#32;save&#32;&apos;number&apos;&#32;to&#32;%r14

&#32;&#32;&#32;&#32;#&#32;(generating&#32;logic&#32;op)&#32;#
&#32;&#32;&#32;&#32;push&#32;%rdx&#32;&#32;&#32;&#32;&#32;#&#32;(save&#32;%rdx)

&#32;&#32;&#32;&#32;cmpq&#32;%r15,&#32;%rdi
&#32;&#32;&#32;&#32;setg&#32;%al
&#32;&#32;&#32;&#32;movzbq&#32;%al,&#32;%rax

&#32;&#32;&#32;&#32;#&#32;(normalize&#32;result)&#32;#
&#32;&#32;&#32;&#32;xor&#32;%rdx,&#32;%rdx
&#32;&#32;&#32;&#32;movq&#32;$100&#32;,&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;imul&#32;%rdi
&#32;&#32;&#32;&#32;mov&#32;%rax,&#32;&#32;&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;#&#32;(-&gt;&#32;normalized&#32;result)

&#32;&#32;&#32;&#32;pop&#32;%rdx&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;(restore&#32;%rdx)

###&#32;br&#32;%op_0,&#32;label&#32;than_0,&#32;label&#32;merge_0
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;%op_0&apos;&#32;already&#32;in&#32;%rdi
&#32;&#32;&#32;&#32;cmp&#32;$100,&#32;%rdi
&#32;&#32;&#32;&#32;je&#32;than_0&#32;
&#32;&#32;&#32;&#32;jmp&#32;merge_0&#32;


than_0:
###&#32;%op_2&#32;=&#32;sub&#32;number,&#32;1
&#32;&#32;&#32;&#32;movq&#32;$100&#32;,&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;&#32;const_1&apos;&#32;-&gt;&#32;%rdi
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;number&apos;&#32;already&#32;in&#32;%r14

&#32;&#32;&#32;&#32;mov&#32;%r14,&#32;&#32;&#32;%r15&#32;&#32;&#32;&#32;&#32;&#32;#&#32;save&#32;&apos;number&apos;&#32;to&#32;%r15

&#32;&#32;&#32;&#32;#&#32;(math&#32;op)&#32;#
&#32;&#32;&#32;&#32;sub&#32;%rdi,&#32;%r14


###&#32;%c_1&#32;=&#32;call:&#32;factorial&#32;(param&#32;%op_2)
&#32;&#32;&#32;&#32;#&#32;(save&#32;busy&#32;regs)&#32;#
&#32;&#32;&#32;&#32;#&#32;(set&#32;parameters)&#32;#&#32;
&#32;&#32;&#32;&#32;mov&#32;%r14,&#32;&#32;&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;call&#32;factorial&#32;
&#32;&#32;&#32;&#32;mov&#32;%rax,&#32;&#32;&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;#&#32;save&#32;call&#32;result&#32;from&#32;rax

###&#32;%op_3&#32;=&#32;mul&#32;number,&#32;%c_1
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;%c_1&apos;&#32;already&#32;in&#32;%rdi
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;number&apos;&#32;already&#32;in&#32;%r15

&#32;&#32;&#32;&#32;mov&#32;%r15,&#32;&#32;&#32;%r14&#32;&#32;&#32;&#32;&#32;&#32;#&#32;save&#32;&apos;number&apos;&#32;to&#32;%r14

&#32;&#32;&#32;&#32;#&#32;(generating&#32;mul/div)#
&#32;&#32;&#32;&#32;push&#32;%rdx&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;(save&#32;%rdx)
&#32;&#32;&#32;&#32;xor&#32;%rdx,&#32;%rdx
&#32;&#32;&#32;&#32;mov&#32;%r15,&#32;&#32;&#32;%rax&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;imul&#32;%rdi

&#32;&#32;&#32;&#32;#&#32;(normalize&#32;result)&#32;&#32;#
&#32;&#32;&#32;&#32;xor&#32;%rdx,&#32;%rdx
&#32;&#32;&#32;&#32;movq&#32;$100&#32;,&#32;%r15&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;idiv&#32;%r15
&#32;&#32;&#32;&#32;mov&#32;%rax,&#32;&#32;&#32;%r15&#32;&#32;&#32;&#32;&#32;&#32;#&#32;(-&gt;&#32;normalized&#32;result)

&#32;&#32;&#32;&#32;pop&#32;%rdx&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;(restore&#32;%rdx)

###&#32;return&#32;%op_3
&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;mov&#32;%r15,&#32;&#32;&#32;%rax&#32;&#32;&#32;&#32;&#32;&#32;#&#32;return&#32;%op_3
&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;#&#32;(restore&#32;callee-save&#32;regs)
&#32;&#32;&#32;&#32;pop&#32;%r15&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r14&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r13&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r12&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r11&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r10&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%rbx&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;

&#32;&#32;&#32;&#32;#&#32;(clear&#32;stack&#32;frame)
&#32;&#32;&#32;&#32;pop&#32;%rbp&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;add&#32;$8,&#32;%rsp&#32;
&#32;&#32;&#32;&#32;ret&#32;

###&#32;br&#32;label&#32;merge_0
&#32;&#32;&#32;&#32;jmp&#32;merge_0&#32;


merge_0:
###&#32;return&#32;1
&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;movq&#32;$100&#32;,&#32;%rax&#32;&#32;&#32;&#32;&#32;&#32;#&#32;return&#32;const_2
&#32;&#32;&#32;&#32;#&#32;restore&#32;callee-save&#32;regs
&#32;&#32;&#32;&#32;pop&#32;%r15&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r14&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r13&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r12&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r11&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r10&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%rbx&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;

&#32;&#32;&#32;&#32;#&#32;clear&#32;stack&#32;frame
&#32;&#32;&#32;&#32;pop&#32;%rbp&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;add&#32;$8,&#32;%rsp&#32;
&#32;&#32;&#32;&#32;ret&#32;


main:
&#32;&#32;&#32;&#32;#&#32;set&#32;stack&#32;frame&#32;(1&#32;local&#32;vars)
&#32;&#32;&#32;&#32;sub&#32;$8,&#32;%rsp&#32;
&#32;&#32;&#32;&#32;push&#32;%rbp&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;mov&#32;%rsp,&#32;&#32;&#32;%rbp&#32;&#32;&#32;&#32;&#32;&#32;

&#32;&#32;&#32;&#32;#&#32;save&#32;callee-save&#32;regs
&#32;&#32;&#32;&#32;push&#32;%rbx&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r10&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r11&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r12&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r13&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r14&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;push&#32;%r15&#32;&#32;&#32;&#32;&#32;

&#32;&#32;&#32;&#32;#&#32;save&#32;param&#32;regs&#32;on&#32;stack


entry_main:
###&#32;%c_0&#32;=&#32;call:&#32;factorial&#32;(param&#32;6)
&#32;&#32;&#32;&#32;#&#32;save&#32;busy&#32;regs
&#32;&#32;&#32;&#32;#&#32;set&#32;parameters&#32;

&#32;&#32;&#32;&#32;movq&#32;$600&#32;,&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;call&#32;factorial&#32;
&#32;&#32;&#32;&#32;mov&#32;%rax,&#32;&#32;&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;#&#32;save&#32;call&#32;result&#32;from&#32;rax

###&#32;result&#32;=&#32;store(%c_0)
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;#&#32;put_value_to_reg:&#32;&apos;%c_0&apos;&#32;already&#32;in&#32;%rdi
&#32;&#32;&#32;&#32;movq&#32;%rdi,&#32;-8&#32;(%rbp)&#32;&#32;#&#32;copy&#32;&apos;%c_0&apos;&#32;to&#32;stack&#32;(to&#32;&apos;result&apos;)

###&#32;call:&#32;fout&#32;(param&#32;result)
&#32;&#32;&#32;&#32;#&#32;save&#32;busy&#32;regs
&#32;&#32;&#32;&#32;push&#32;%rdi&#32;&#32;&#32;&#32;&#32;#&#32;save:&#32;%c_0
&#32;&#32;&#32;&#32;#&#32;set&#32;parameters&#32;
&#32;&#32;&#32;&#32;movq&#32;-8&#32;(%rbp),&#32;%rdi&#32;&#32;
&#32;&#32;&#32;&#32;call&#32;fout&#32;
&#32;&#32;&#32;&#32;pop&#32;%rdi&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;

###&#32;return&#32;0
&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;movq&#32;$0&#32;&#32;&#32;,&#32;%rax&#32;&#32;&#32;&#32;&#32;&#32;#&#32;return&#32;const_1
&#32;&#32;&#32;&#32;#&#32;restore&#32;callee-save&#32;regs
&#32;&#32;&#32;&#32;pop&#32;%r15&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r14&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r13&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r12&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r11&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%r10&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;pop&#32;%rbx&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;

&#32;&#32;&#32;&#32;#&#32;clear&#32;stack&#32;frame
&#32;&#32;&#32;&#32;pop&#32;%rbp&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
&#32;&#32;&#32;&#32;add&#32;$8,&#32;%rsp&#32;
&#32;&#32;&#32;&#32;ret&#32;
</computeroutput></literallayout></para>

<para>&lt;/details&gt;</para>
</section>
<section xml:id="_index_1autotoc_md6">
<title>Стандартная библиотека</title>

<para>Для полноценной использования языка необходима библиотека, реализующая простейшие стандартные функции. Моя реализация некоторых функций находится в файле <computeroutput>src/Elf/stdlib.s</computeroutput>. Машинный код стандартных функций берется из файла <computeroutput>src/Elf/stdlib.o</computeroutput> и добавляется в конец исполняемого файла.</para>

<para>Для создания контрольной программы с помощью генерирующегося ассемблерного кода, нужно линковать <computeroutput>src/Elf/stdlib.o</computeroutput>.</para>
</section>
</section>
<section xml:id="_index_1autotoc_md7">
<title>Итог:</title>

<para>В завершении работы замерим, как изменилось время работы программы на моем языке. Для сравнения будем использовать пример факториала из данной работы, но без вывода результата.</para>
<section xml:id="_index_1autotoc_md8">
<title>Таблица: время расчета факториала от 15, 1000 раз</title>

<para><informaltable frame="all">
    <tgroup cols="3" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
      <colspec colname='c3'/>
<thead>
      <row  class='markdownTableHead'>
<entry>
<para>Исполнитель   </para>
</entry><entry>
<para>Время, мс   </para>
</entry><entry>
<para>Коэффициент прироста    </para>
</entry></row>
</thead><tbody>
      <row  class='markdownTableRowOdd'>
<entry>
<para>SoftCpu   </para>
</entry><entry>
<para>70   </para>
</entry><entry>
<para>-    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para>core i5   </para>
</entry><entry>
<para>1.2   </para>
</entry><entry>
<para>56.6   </para>
</entry></row>
    </tbody>
    </tgroup>
</informaltable>
</para>

<para>Получается, что в новой итерации исполнение программы ускорилось более чем в 50 раз! Хороший показатель (спасибо ребятам из <emphasis>Intel</emphasis> за такой мощный процессор ;)). </para>
</section>
</section>
</chapter>
